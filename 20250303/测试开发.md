面试官，你好！我叫黄昱桥，2021年毕业于湖北工业大学工程技术学院计算机科学与技术专业。我拥有3年的软件开发与测试经验，上一家公司是在亚信科技担任软件测试工程师，负责项目的软件测试、开发工作。
在上一家公司，我的主要职责包括：担任测试小组组长，负责制定测试计划，分解测试任务，安排功能上线，设计并执行自动化测试脚本，编写详尽的测试报告，确保项目测试覆盖率和有效性。其中在中国移动收钱宝项目中我开发了Python自动化测试工具，将测试效率提升30%。
我掌握自动化和常用测试技术，熟悉Postman、Jmeter等测试工具，熟练掌握Java、Python、Vue，React等开发技术，掌握SQL语言和数据库知识，掌握Linux、Docker，有测试、开发环境搭建能力，熟练使用Git进行版本控制。 并且我持有PMP认证，能够高效协调团队资源。



#### 工作内容

> **Q：按测试内容划分，测试有哪些种类？**
>
> 功能测试、性能测试、安全测试、兼容性测试、界面测试、易用性测试、可靠性测试、配置测试、数据库测试、接口测试、本地化测试、恢复测试、文档测试和安装测试等。
>
> 
>
> **Q：软件开发（测试）的流程是怎么样的？**
>
> 软件开发测试流程：需求分析 → 测试计划 → 测试设计 → 测试环境搭建 → 测试执行 → 缺陷跟踪与管理 → 测试报告 → 回归测试 → 验收测试。
>
> 
>
> **Q：你印象最深刻的 bug 是？**
>
> 在中国移动收钱宝项目中，我们曾遇到遇到一些用户反馈查不到订单的问题。这就是丢单了，顺便去我就去定位了一下这些订单是怎么丢的，然后根据用户说的支付时间，去查日志，什么也没查到，想了想我就去数据库查了一下，发现订单是在数据库里的，再排查才知道是是往es写入的时候出错了，由于前台是查的es，所以没订单，最后在投产日通过手动补单的方式先补上了订单。再在下一个迭代周期上线了通过xxljob定时任务去扫描数据库和es的方式去彻底解决了这个问题。
>
> 
>
> **Q：APP的一个页面，你怎么区分是原生Native页面，还是H5？**
>
> 性能体验：Native页面响应更快，滑动更流畅，H5页面可能有明显延迟
>
> 网络状态：H5页面在无网络状态下通常无法加载，而缓存好的Native页面可以
>
> 元素检查：查看网页源码或使用开发者工具，H5页面基于HTML/CSS
>
> 右键菜单：H5页面可以使用浏览器右键菜单，Native页面通常不支持
>
> 查看URL：H5页面通常有URL(可能是内部webview地址)
>
> 界面风格：H5页面可能与系统风格不完全一致





#### 测试方法

> Q：**黑盒测试的方法有哪些？**
>
> 等价类划分：将输入数据分为有效等价类和无效等价类
>
> 边界值分析：测试边界条件（如最小/最大值，临界值）
>
> 错误推测：根据经验预测可能出现错误的地方
>
> 因果图：分析输入条件与输出结果的关系
>
> 决策表测试：处理不同条件组合的测试方法
>
> 场景测试：模拟用户使用场景
>
> 正交数组测试：减少测试用例数量但保持覆盖率
>
> 状态转换测试：测试系统在不同状态间的转换
>
> 
>
> Q：**白盒测试的方法有哪些？**
>
> 语句覆盖：确保每个语句至少执行一次
>
> 判定覆盖（分支覆盖）：确保每个决策的每个可能结果至少执行一次
>
> 条件覆盖：确保每个条件的每个可能结果至少执行一次
>
> 判定/条件覆盖：结合判定覆盖和条件覆盖
>
> 条件组合覆盖：测试所有条件的组合
>
> 路径覆盖：确保程序中所有可能的路径都被测试
>
> 基本路径测试：基于代码的循环复杂度设计测试用例
>
> 数据流测试：追踪变量的定义和使用
>
> 
>
> Q：**什么是单元测试？**
>
> 单元测试是对软件中最小可测试单元（通常是函数、方法或类）进行验证的测试方法。它由开发人员编写，目的是确保代码功能正确。单元测试通常使用框架（如JUnit、PyTest）自动化执行，并且应该是隔离的、快速的、可重复的。好的单元测试能提早发现问题，便于重构，并作为代码的文档。
>
> 
>
> Q：**什么是集成测试？**
>
> 集成测试是在单元测试之后进行的，测试多个已经过单元测试的模块组合在一起是否能正确工作。目的是发现接口缺陷或模块之间交互的问题。集成测试可采用自顶向下、自底向上或混合的策略，一般需要更复杂的测试环境和数据，测试范围更广，执行更慢。
>
> 
>
> Q：**测试用例怎么编写与设计？**
>
> 分析需求文档，理解功能和业务规则
>
> 确定测试边界和范围
>
> 使用黑盒测试方法（等价类划分、边界值分析等）
>
> 考虑正向测试（验证正常功能）和反向测试（验证异常处理）
>
> 设计测试数据，包括有效和无效数据
>
> 明确测试前提、步骤和预期结果
>
> 评审并优化测试用例，确保测试覆盖率
>
> 设置优先级，重要功能优先测试
>
> 
>
> Q：**什么是灰盒测试？**
>
> 灰盒测试介于黑盒和白盒测试之间，测试人员了解部分内部结构，但不需完全了解源代码。
>
> 结合了黑盒和白盒测试的优点
>
> 基于有限的结构信息设计测试用例
>
> 可以针对特定的内部路径设计测试
>
> 适合测试数据库、安全性、面向对象等场景
>
> 能更高效地发现基于数据流和内部边界的问题



#### 自动化测试

> Q：**举例说明，都有哪些功能可以用自动化来进行？**
>
> 回归测试：检验新变更是否影响现有功能
>
> 冒烟测试：验证基本功能是否正常工作
>
> 接口测试：验证API响应和数据正确性
>
> 数据驱动测试：相同测试流程使用多组数据
>
> 登录验证：不同账号权限的登录测试
>
> 表单验证：大量输入字段的有效性检查
>
> 性能测试：负载测试、压力测试、并发测试
>
> 兼容性测试：不同浏览器/设备/系统的测试
>
> 定时任务：检查系统定时作业是否正常执行
>
> 
>
> Q：**如何判断一个功能能否进行自动化测试？**
>
> 执行频率：高频执行的测试更适合自动化
>
> 稳定性：功能本身稳定，变动不频繁
>
> 技术可行性：技术上可以实现自动化
>
> 投资回报：自动化带来的收益大于成本
>
> 测试复杂度：测试步骤可以清晰定义
>
> 测试数据：能否生成或获取足够测试数据
>
> 环境因素：测试环境是否支持自动化
>
> 
>
> Q：**定位xpath路径都有哪些方法？**
>
> 绝对路径：从根节点到目标元素的完整路径 (`/html/body/div/span`)
>
> 相对路径：以双斜线开始的相对定位 (`//div[@id='login']`)
>
> 属性定位：通过元素属性定位 (`//input[@name='username']`)
>
> 文本定位：通过元素文本内容定位 (`//button[text()='登录']`)
>
> 包含文本：定位包含特定文本的元素 (`//div[contains(text(),'欢迎')]`)
>
> 包含属性：定位包含特定属性的元素 (`//input[contains(@class,'btn')]`)
>
> 索引定位：通过位置索引定位 (`//div[@class='item'][1]`)
>
> Q：**如何定位一个动态的元素？**
>
> 使用部分ID/class定位：`//div[contains(@id,'login_')]`
>
> 使用稳定的父元素定位：`//div[@id='stable-parent']//input`
>
> 使用相邻元素定位：`//label[text()='用户名']/following-sibling::input`
>
> 使用CSS选择器匹配部分属性：`css=input[id*='part_of_id']`
>
> 使用XPath的starts-with函数：`//div[starts-with(@id,'prefix_')]`
>
> 使用XPath的ends-with函数：`//div[ends-with(@id,'_suffix')]`
>
> 使用相对稳定的属性：如name、type、placeholder等
>
> 使用元素的位置关系：父子、兄弟、祖先等
>
> 等待元素出现后再定位：使用显式或隐式等待
>
> Q：**如何定位类似于悬浮在web页面上的元素（类似于web上飞来飞去的广告）**
>
> **使用z-index属性定位：`//div[contains(@style,'z-index')]`**
>
> **定位iframe内的元素：广告常在iframe中，先切换到iframe再定位**
>
> 使用position属性定位：`//div[contains(@style,'position:fixed')]`
>
> 通过可见性等待：使用WebDriverWait等待元素可见
>
> 使用JavaScript执行器定位：`document.getElementsByClassName('ad-class')`
>
> **使用元素特征定位：广告通常有特定class或id模式**
>
> 通过事件处理：在元素出现时捕获事件
>
> 通过截图对比：检测页面变化来定位动态元素
>
> **使用特殊框架API：如Selenium的Actions类处理悬浮元素**
>
> 
>
> Q：**列举你知道的自动化测试工具**
>
> Web自动化：**Selenium**、**RPA**
>
> 移动应用测试：Appium
>
> API测试：**Postman**、RestAssured、**JMeter**、SoapUI、Karate
>
> 性能测试：**JMeter**、LoadRunner、Gatling、Locust、K6
>
> 单元测试：**JUnit**、TestNG、**Pytest**、NUnit、Mocha
>
> 持续集成：**Jenkins**、GitHub Actions、Travis CI、CircleCI、GitLab CI



#### 测试工具

> Q：**聊聊 fiddler 的抓包原理**
>
> 代理机制：Fiddler作为中间人代理，在本地建立HTTP/HTTPS代理服务器（默认端口8888）
>
> 流量重定向：将浏览器或应用的网络请求重定向到Fiddler代理
>
> 请求拦截：Fiddler拦截客户端发出的请求，记录并显示请求内容
>
> 转发请求：将拦截的请求转发给实际的目标服务器
>
> 响应拦截：同样拦截服务器的响应，记录并显示响应内容
>
> 转发响应：将响应传回客户端
>
> 
>
> Q：**fiddler 怎么抓取 https 请求？**
>
> 生成并安装根证书：Tools > Options > HTTPS > Actions > Generate CA Certificate
>
> 信任Fiddler证书：安装证书到受信任的根证书颁发机构
>
> 开启HTTPS解密：勾选"Decrypt HTTPS Traffic"选项
>
> 配置浏览器代理：指向Fiddler代理(127.0.0.1:8888)
>
> 原理：Fiddler作为中间人，与客户端建立HTTPS连接，再与服务器建立另一个HTTPS连接
>
> 证书替换：Fiddler使用自己的证书替换服务器证书，解密后再加密传输
>
> 排除特定域名：可配置不解密特定域名的HTTPS流量
>
> 移动设备配置：需要在设备上安装Fiddler证书并设置代理



#### 性能测试

> Q：**性能测试如何做的？**
>
> 需求分析：确定性能指标和测试目标
>
> 测试计划：定义测试场景、负载模型和测试环境
>
> 脚本开发：编写性能测试脚本（如JMeter、LoadRunner）
>
> 环境准备：配置测试环境、监控工具和数据收集方式
>
> 基准测试：建立系统基准性能
>
> 负载测试：逐步增加用户负载，监测系统表现
>
> 压力测试：测试系统在极限负载下的表现
>
> 稳定性测试：长时间运行系统验证稳定性
>
> 数据分析：分析响应时间、吞吐量、资源使用率等
>
> 瓶颈定位：发现系统瓶颈并提出优化建议
>
> 优化验证：验证优化措施的效果
>
> 测试报告：生成完整的性能测试报告
>
> 
>
> Q：**性能测试需要关注哪些方面？**
>
> 响应时间：用户请求的响应速度
>
> 吞吐量：系统单位时间处理的事务数量（TPS/QPS）
>
> 并发用户数：系统能够同时支持的用户数量
>
> 资源利用率：CPU、内存、磁盘I/O、网络带宽使用情况
>
> 稳定性：系统长时间运行的可靠性
>
> 瓶颈点：系统中的性能瓶颈和限制因素
>
> 错误率：系统在负载下的错误发生率
>
> 数据库性能：SQL执行时间、连接数、缓存命中率
>
> 扩展性：系统处理能力随资源增加的变化情况
>
> 敏感操作：特定关键业务操作的性能
>
> 负载均衡：多服务器环境下的负载分布情况
>
> 缓存效率：缓存系统的命中率和响应时间



#### 排查问题的思路

> Q：**网页崩溃的原因是什么？**
>
> JavaScript错误：未捕获的异常或无限循环
>
> 内存泄漏：长时间运行导致内存累积
>
> DOM操作过多：频繁或大量DOM操作导致浏览器无响应
>
> 插件冲突：浏览器插件与网页脚本冲突
>
> 资源过大：加载过大的图片或视频文件
>
> 网络问题：请求超时或网络不稳定
>
> 
>
> Q：**有个用户反馈上传头像失败，分析原因？**
>
> 文件大小：超出系统允许的最大上传大小
>
> 文件格式：不支持的图片格式（非JPG/PNG等）
>
> 网络问题：上传过程中网络不稳定或中断
>
> 服务器限制：服务器配置限制（如PHP的upload_max_filesize）
>
> 权限问题：存储目录权限不足
>
> 磁盘空间：服务器存储空间不足
>
> 会话超时：上传过程中用户会话过期
>
> 前端验证：前端JavaScript验证错误
>
> 浏览器兼容性：特定浏览器的上传功能问题
>
> 防病毒软件：客户端安全软件拦截上传
>
> 服务器负载：服务器过载无法处理上传请求
>
> 第三方服务问题：如使用云存储服务出现故障
>
> 
>
> Q：**app闪退的原因？**
>
> 内存溢出（OOM）：应用占用内存过多
>
> 未捕获的异常：代码中存在未处理的异常
>
> 线程问题：主线程阻塞或线程同步问题
>
> 系统版本兼容性：应用与特定系统版本不兼容
>
> 资源访问权限：缺少必要的权限（如相机、存储等）
>
> 硬件兼容性：特定设备的硬件不兼容
>
> 网络问题：网络请求处理不当
>
> 过度频繁的UI更新：造成UI渲染负担过重
>
> 数据库操作错误：数据库读写异常
>
> 第三方库冲突：集成的第三方SDK冲突
>
> 应用配置错误：应用配置文件错误
>
> 系统资源不足：设备资源（如RAM）不足
>
> 
>
> Q：**网页卡顿的原因是什么？**
>
> JavaScript执行效率低：长时间运行的JS阻塞主线程
>
> DOM操作频繁：过多或低
>
> 
>
> Q：**10%的用户反馈用不了功能，你讲如何排查？**
>
> 数据收集和分析
>
> - 确认具体是哪些功能无法使用
> - 收集这10%用户的共同特征（使用设备、系统版本、地理位置、账户类型等）
> - 分析错误日志和用户行为数据
> - 查看问题是从什么时间开始出现的
>
> 环境因素排查
>
> - 检查这些用户是否使用特定的浏览器/设备/操作系统
> - 确认是否有特定的网络环境限制（公司防火墙、区域性限制等）
> - 检查是否与第三方插件或安全软件冲突
>
> 账户权限排查
>
> - 验证这些用户的权限设置是否正确
> - 检查账户状态（是否处于特殊状态或受限模式）
> - 确认是否有用户分组或特征标签影响功能访问
>
> 技术层面排查
>
> - 检查最近的代码更新是否影响了特定用户群体
> - 验证API调用是否对部分用户失败
> - 排查缓存或会话管理问题
> - 检查数据库访问是否存在问题
>
> 
>
> Q：**登录的按钮不能点击，如何排查问题？**
>
> 检查前端代码和样式问题
>
> - 查看按钮是否被其他元素覆盖（z-index问题）
> - 检查按钮的点击区域是否正确设置
> - 确认按钮的禁用状态(disabled属性)是否被错误设置
> - 检查CSS样式是否有pointer-events: none的设置
>
> 验证交互逻辑
>
> - 确认是否有JavaScript逻辑在阻止点击事件
> - 检查表单验证逻辑是否正确，是否在表单未完成时禁用按钮
> - 验证事件监听器是否正确绑定到按钮上
>
> 测试不同场景
>
> - 在不同浏览器中测试（Chrome, Firefox, Safari等）
> - 在不同设备上测试（桌面端、移动端）
> - 测试不同网络环境下的表现
>
> 检查与后端交互
>
> - 查看网络请求是否有错误导致前端锁定按钮
> - 确认API响应是否正常
> - 检查是否有防止重复提交的逻辑导致按钮被锁定
>
> 用户权限和状态检查
>
> - 确认用户是否有登录权限
> - 检查用户账户状态是否正常
> - 验证是否有IP或地区限制
>
> 应用程序状态
>
> - 检查应用是否处于维护模式
> - 确认服务器状态是否正常
> - 检查是否有全局错误影响UI交互
>
> 开发者工具调试
>
> - 使用浏览器开发者工具检查控制台错误
> - 检查元素检查器中按钮的实际状态
> - 尝试在控制台中手动触发点击事件看是否有响应
>
> 
>
> Q：**压测的时候，QPS一直上不去，你会怎么排查？**
>
> 检查压测工具配置
>
> - 确认压测工具本身的配置是否正确（线程数、连接数等）
> - 验证压测机器的资源是否足够（CPU、内存、网络带宽）
> - 检查是否压测工具本身成为了瓶颈
>
> 网络层面排查
>
> - 检查网络带宽是否成为限制
> - 确认网络连接数是否达到上限
> - 查看是否有网络延迟或丢包
> - 排查防火墙或负载均衡器的限制
>
> 系统资源监控
>
> - CPU使用率（是否接近100%）
> - 内存使用情况（是否有大量交换）
> - 磁盘I/O（是否出现I/O等待）
> - 网络I/O（是否达到网卡极限）
>
> 应用层面排查
>
> - 线程池配置是否合理
> - 数据库连接池设置是否适当
> - JVM参数是否优化（如果是Java应用）
> - 应用是否有锁竞争或同步瓶颈
>
> 数据库排查
>
> - 慢查询分析
> - 数据库连接数是否达到限制
> - 索引使用是否合理
> - 事务锁定情况
>
> 中间件检查
>
> - 缓存使用情况（如Redis、Memcached）
> - 消息队列处理能力（如Kafka、RabbitMQ）
> - API网关或服务网格限流设置
>
> 系统架构分析
>
> - 识别系统中的串行处理部分
> - 检查是否存在单点瓶颈
> - 评估系统的可扩展性设计
>
> 日志和监控指标分析
>
> - 检查错误日志和异常
> - 分析关键性能指标
> - 利用APM工具（如Skywalking、Pinpoint）定位瓶颈
>
> 
>
> Q：**APP提示无法连接网络，你会如何排查？**
>
> 基础网络连接检查
>
> - 确认设备是否真的已连接到WiFi或移动数据
> - 测试其他应用是否能正常连接网络
> - 尝试访问知名网站（如百度）验证网络连通性
> - 检查是否开启了飞行模式
>
> APP特定问题排查
>
> - 检查APP是否有网络权限
> - 确认是否对特定APP限制了后台数据使用
> - 检查APP版本是否为最新版本
> - 尝试清除APP缓存和数据后重试
> - 卸载并重新安装APP
>
> 网络环境问题
>
> - 尝试切换WiFi和移动数据
> - 检查WiFi信号强度
> - 测试不同的网络环境（如其他WiFi网络）
> - 重启路由器/调制解调器
> - 检查DNS设置是否正常
>
> 设备问题排查
>
> - 重启设备
> - 检查设备时间和日期设置是否正确
> - 检查设备存储空间是否充足
> - 更新设备系统版本
> - 检查是否安装了影响网络的软件（如VPN、防火墙）
>
> 特定网络限制检查
>
> - 确认网络是否有防火墙限制
> - 检查公司/学校网络是否限制了特定应用
> - 检查IP是否被封禁
> - 验证服务器区域访问限制
>
> 服务器端问题
>
> - 检查APP服务器状态（可通过官方社交媒体或状态页面）
> - 查看是否有其他用户报告类似问题
> - 联系APP客服了解是否有已知服务中断
>
> 
>
> Q：**怎么判断一个BUG到底是前端的BUG还是后端的BUG？**
>
> 数据不正确但格式正确：通常是后端问题
>
> 数据格式错误或解析错误：可能是前后端接口定义不一致
>
> 界面渲染问题：通常是前端问题
>
> 服务器报错(500等)：通常是后端问题
>
> 请求未到达服务器：可能是前端问题或网络问题
>
> 我会采用隔离测试法，使用像Postman这样的工具直接测试后端API，确认原始数据是否正确。同时，我会检查前端日志和后端日志，寻找错误信息。我还会考虑重现步骤、环境因素，并进行比较测试（不同浏览器、不同设备）来缩小问题范围。当确认问题后，我会建立详细的复现文档，包括环境信息、操作步骤、预期结果与实际结果的对比，以及相关的网络请求和响应数据，帮助开发团队快速定位问题。



#### 实战案例

> **Q：微博发动态，设计一下测试点**
>
> **1. 功能性测试：**
>
> - 文本内容：
>   - 正常文本输入：测试各种字符类型（中文、英文、数字、特殊字符）、长度限制（最大字符数、最小字符数）、换行、空格等。
>   - 特殊文本输入：测试表情符号、@用户、#话题#、URL链接、HTML标签、JavaScript代码等。
>   - 文本编辑：测试复制、粘贴、剪切、撤销、重做等功能。
>   - 敏感词过滤：测试是否能正确过滤敏感词汇。
> - 图片/视频：
>   - 图片上传：测试不同格式（JPG、PNG、GIF等）、大小、分辨率的图片上传，多图上传、图片裁剪、图片旋转等。
>   - 视频上传：测试不同格式（MP4、AVI等）、大小、时长的视频上传。
>   - 图片/视频与文本同时上传测试。
>   - 图片/视频删除测试。
> - 定位：
>   - 定位功能：测试能否准确获取地理位置、搜索附近地点、选择地点等。
>   - 定位权限测试，无权限是否能正常发布。
> - 可见性：
>   - 可见范围：测试公开、私密、分组可见等选项是否生效。
> - 发布操作：
>   - 发布按钮：测试点击发布按钮后的状态、发布成功/失败的提示信息。
>   - 发布后，内容是否正确显示在个人主页。
>   - 发布后，内容是否正确推送到粉丝时间线。
>   - 测试网络异常，发布失败的情况。
>
> **2. 性能测试：**
>
> - 响应时间：
>   - 测试发布动态的响应时间，包括文本、图片、视频等不同情况。
>   - 测试高并发情况下，发布动态的响应时间。
> - 资源消耗：
>   - 测试发布动态时CPU、内存、网络等资源消耗情况。
>
> **3. 安全性测试：**
>
> - XSS攻击：
>   - 测试是否能通过输入特殊字符或代码进行XSS攻击。
> - SQL注入：
>   - 测试是否能通过输入特殊字符进行SQL注入。
> - 权限控制：
>   - 测试未授权用户是否能发布动态。
> - 数据安全：
>   - 测试用户发布的内容是否被正确存储和保护。
>
> **4. 兼容性测试：**
>
> - 浏览器兼容性：
>   - 测试在不同浏览器（Chrome、Firefox、Safari、Edge等）下的显示和功能是否正常。
> - 移动端兼容性：
>   - 测试在不同操作系统（iOS、Android）和不同分辨率的移动设备上的显示和功能是否正常。
>
> **5. 用户体验测试：**
>
> - 界面布局：
>   - 测试界面布局是否合理、美观。
> - 操作流程：
>   - 测试发布动态的操作流程是否简洁、易用。
> - 提示信息：
>   - 测试提示信息是否清晰、易懂。
>
> **6. 异常测试：**
>
> - 网络异常：
>   - 测试在网络不稳定或断开的情况下发布动态的表现。
> - 服务器异常：
>   - 测试在服务器故障或维护的情况下发布动态的表现。
> - 输入异常：
>   - 测试输入超长文本，超大图片，不支持的视频格式等情况下，发布动态的表现
>
> 
>
> **Q：对一台自动售货机进行测试用例设计**
>
> **功能性测试：**
>
> - 商品选择：
>   - 测试能否正确选择不同商品。
>   - 测试选择不存在的商品，是否给出正确提示。
>   - 测试选择商品后，商品信息（名称、价格）是否正确显示。
>   - 测试商品库存不足时，是否给出正确提示。
> - 投币/支付：
>   - 测试能否正确识别不同面额的硬币/纸币。
>   - 测试能否识别假币/无效货币。
>   - 测试支持的支付方式（微信、支付宝、银行卡等）是否能正常使用。
>   - 测试支付金额是否正确扣除。
>   - 测试支付过程中断，是否能正确退款。
>   - 测试能否正确找零。
> - 出货：
>   - 测试能否正确出货。
>   - 测试出货过程中卡住商品，是否给出正确提示。
>   - 测试出货后，商品库存是否正确更新。
>   - 测试出货口是否安全，防止夹手等危险。
> - 显示屏：
>   - 测试显示屏能否正常显示商品信息、价格、支付信息、提示信息等。
>   - 测试显示屏在不同光线条件下，是否清晰可见。
>   - 测试广告播放是否正常，声音是否正常。
> - 退币：
>   - 测试退币按钮是否正常工作。
>   - 测试是否能正确退回投入的硬币。
>   - 测试在各种情况下，退币功能是否正常。
>
> **2. 性能测试：**
>
> - 响应时间：
>   - 测试选择商品、支付、出货等操作的响应时间。
>   - 测试在高并发情况下，自动售货机的响应时间。
> - 稳定性：
>   - 测试自动售货机在长时间运行下的稳定性。
>   - 测试在各种温度，湿度下，是否能稳定运行。
>
> **3. 安全性测试：**
>
> - 支付安全：
>   - 测试支付过程中的数据加密和安全传输。
>   - 测试防止支付漏洞，如重复支付、恶意支付等。
> - 防盗安全：
>   - 测试自动售货机的防盗性能，如防撬、防破坏等。
>   - 测试监控系统是否正常工作，是否能记录异常情况。
> - 食品安全：
>   - 测试售卖食品的自动售货机，是否符合食品安全标准。
>   - 测试自动售货机的温度控制，是否能保证食品质量。
>
> **4. 兼容性测试：**
>
> - 支付方式兼容性：
>   - 测试自动售货机支持的各种支付方式的兼容性。
> - 货币兼容性：
>   - 测试自动售货机支持的各种货币的兼容性。
> - 环境兼容性：
>   - 测试在不同的环境温度，湿度下，自动售货机是否能正常工作。
>
> **5. 用户体验测试：**
>
> - 操作界面：
>   - 测试操作界面是否简洁、易懂。
>   - 测试操作流程是否流畅。
> - 提示信息：
>   - 测试提示信息是否清晰、准确。
> - 易用性：
>   - 测试自动售货机是否易于使用，是否符合人体工程学。
>
> **6. 异常测试：**
>
> - 断电：
>   - 测试断电后，自动售货机是否能恢复正常工作。
>   - 测试断电后，是否会造成资金损失。
> - 网络异常：
>   - 测试网络异常情况下，支付功能是否能正常工作。
>   - 测试网络异常情况下，后台数据是否会丢失。
> - 硬件故障：
>   - 测试硬件故障情况下，自动售货机是否能给出正确提示。
>   - 测试硬件故障情况下，是否会造成资金损失。
>
> 
>
> **Q：设计微信扫码支付的测试用例**
>
> **扫码功能：**
>
> - 测试能否正确扫描不同清晰度、大小的二维码。
> - 测试在不同光线条件下，能否正常扫码。
> - 测试能否扫描其他平台的二维码，是否给出正确提示。
> - 测试能否扫描无效的二维码，是否给出正确提示。
>
> **支付流程：**
>
> - 测试扫描二维码后，能否正确显示商品信息和价格。
> - 测试能否正确选择支付方式（微信零钱、银行卡等）。
> - 测试输入正确的支付密码，能否完成支付。
> - 测试输入错误的支付密码，能否给出正确提示。
> - 测试支付过程中断，是否能取消支付。
> - 测试支付成功后，能否正确显示支付结果。
> - 测试支付成功后，能否在微信支付记录中查到交易信息。
> - 测试支付成功后，商家是否能收到支付信息。
>
> **金额校验：**
>
> - 测试支付金额与商品金额是否一致。
> - 测试输入负数金额，或0元能否正确拦截。
>
> **交易状态：**
>
> - 测试交易成功，失败，交易关闭等状态是否能正确显示。
> - 测试交易关闭后，是否能重新发起支付。
>
> **退款功能：**
>
> - 测试能否发起退款。
> - 测试退款金额是否正确。
> - 测试退款后，用户是否能收到退款。
> - 测试退款后，商家是否能收到退款信息。
>
> 
>
> **Q：如果手机浏览器输入 baidu.com打不开页面，你会怎么排查？**
>
> **1. 网络连接检查：**
>
> - 确认网络状态：
>   - 首先，检查手机是否已连接到互联网（Wi-Fi 或移动数据）。
>   - 尝试打开其他网站或应用程序，确认网络连接是否正常。
>   - 如果使用 Wi-Fi，尝试重启路由器或连接其他 Wi-Fi 网络。
>   - 如果使用移动数据，确认信号强度是否良好，尝试切换到Wi-Fi。
> - 检查网络设置：
>   - 检查手机的网络设置，确保没有启用代理服务器或 VPN。
>   - 尝试关闭并重新打开 Wi-Fi 或移动数据。
>   - 尝试飞行模式开关，然后关闭，重新建立网络连接。
>
> **2. 浏览器问题排查：**
>
> - 清除浏览器缓存和 Cookie：
>   - 浏览器缓存和 Cookie 可能会导致网页加载问题。尝试清除浏览器缓存和 Cookie。
>   - 尝试使用浏览器的隐私模式，看是否可以打开。
> - 尝试其他浏览器：
>   - 尝试使用其他手机浏览器（如 Chrome、Firefox、Safari 等）打开 `baidu.com`，以确定是否是特定浏览器的问题。
>   - 如果其他浏览器可以打开，则可能是原浏览器存在问题，尝试更新或重装浏览器。
> - 检查浏览器设置：
>   - 检查浏览器设置，确保 JavaScript 已启用。
>   - 尝试禁用浏览器插件或扩展程序，看是否能解决问题。
> - 检查浏览器版本：
>   - 确保浏览器是最新版本，旧版本可能存在兼容性问题。
>
> **3. DNS 问题排查：**
>
> - 尝试更改 DNS 服务器：
>   - DNS 服务器负责将域名解析为 IP 地址。如果 DNS 服务器出现问题，可能导致无法打开网页。
>   - 尝试将手机的 DNS 服务器更改为公共 DNS 服务器（如 Google DNS 8.8.8.8 和 8.8.4.4，或 Cloudflare DNS 1.1.1.1 和 1.0.0.1）。
> - 清除 DNS 缓存：
>   - 尝试清除手机的DNS缓存。
>
> **4. 网站问题排查：**
>
> - 尝试使用 IP 地址访问：
>   - 尝试使用 `baidu.com` 的 IP 地址（可以通过在电脑上 ping `baidu.com` 获取）直接在浏览器中访问，以确定是否是 DNS 解析问题。
> - 检查网站状态：
>   - 使用网站状态检查工具（如 Down for Everyone or Just Me）检查 `baidu.com` 是否正常运行。
> - 尝试在其他设备上访问：
>   - 尝试在其他手机或电脑上访问`baidu.com`,确认是否仅是当前设备的问题。
>
> **5. 手机系统问题排查：**
>
> - 重启手机：
>   - 重启手机可以解决一些临时性的软件问题。
> - 更新手机系统：
>   - 确保手机系统是最新版本，旧版本可能存在兼容性问题。
> - 检查防火墙或安全软件：
>   - 查看手机是否安装有防火墙或者安全软件，确认是否拦截了浏览器的网络请求。
>
> **6. 其他可能的原因：**
>
> - 运营商问题：
>   - 可能是运营商的网络问题导致无法访问特定网站。
> - 手机硬件问题：
>   - 极少数情况下，手机硬件问题也可能导致网络连接问题。
>
> 
>
> **Q：设计输入框测试用例？**
>
> **功能性测试：**
>
> - 字符类型：验证允许和禁止的字符。
> - 长度限制：测试边界值和超长输入。
> - 输入格式：验证特定格式（如邮箱、电话）的正确性。
> - 必填项：验证未输入时的提示。
> - 特殊字符：测试特殊字符的处理和安全性。
> - 敏感词过滤：验证是否对敏感词汇有正确的过滤。
>
> **安全性测试：**
>
> - XSS 和 SQL 注入：防止恶意代码和注入。
> - 数据安全：验证输入数据的加密。
>
> **兼容性测试：**
>
> - 浏览器和移动端：验证在不同平台上的显示和功能。
>
> **用户体验测试：**
>
> - 界面布局和提示信息：确保易用性和清晰度。
>
> **异常测试：**
>
> - 网络和服务器异常：测试在异常情况下的表现。
>
> 
>
> **Q：编写一个登录界面的测试用例？**
>
> **1. 功能性测试：**
>
> - 正常登录：
>   - 输入正确的用户名和密码，验证是否能成功登录。
>   - 测试用户名和密码的大小写敏感性。
> - 异常登录：
>   - 输入错误的用户名，验证是否给出错误提示。
>   - 输入错误的密码，验证是否给出错误提示。
>   - 用户名或密码为空，验证是否给出错误提示。
>   - 输入特殊字符，验证是否能正确处理。
>   - 连续多次输入错误密码，验证是否触发账户锁定机制。
> - 找回密码：
>   - 测试“忘记密码”链接是否能正确跳转到找回密码页面。
>   - 验证找回密码流程是否正确。
> - 记住密码：
>   - 勾选“记住密码”选项，验证下次打开页面是否自动填充用户名和密码。
>   - 验证记住密码的有效期。
> - 验证码：
>   - 验证码功能，验证输入错误验证码时能否登录失败，并刷新验证码。
>   - 验证码的刷新机制，刷新后验证码是否有效。
>
> **2. 安全性测试：**
>
> - 密码安全性：
>   - 验证密码是否以星号或圆点显示。
>   - 验证密码是否限制复制粘贴。
>   - 验证密码在网络传输过程中是否加密。
>   - 验证密码在数据库中是否加密存储。
> - 防暴力破解：
>   - 测试连续多次输入错误密码，是否触发账户锁定机制。
>   - 测试验证码机制是否能有效防止暴力破解。
> - 会话管理：
>   - 验证登录后，会话是否安全管理。
>   - 验证退出登录后，会话是否正确销毁。
> - SQL注入：
>   - 测试登录界面是否能防止SQL注入。
>
> **3. 性能测试：**
>
> - 响应时间：
>   - 测试登录界面的加载时间。
>   - 测试登录操作的响应时间。
>   - 在高并发情况下，测试登录操作的响应时间。
> - 资源消耗：
>   - 测试登录界面在不同浏览器和设备上的资源消耗。
>
> **4. 兼容性测试：**
>
> - 浏览器兼容性：
>   - 测试登录界面在不同浏览器（Chrome、Firefox、Safari、Edge等）下的显示和功能是否正常。
> - 移动端兼容性：
>   - 测试登录界面在不同操作系统（iOS、Android）和不同分辨率的移动设备上的显示和功能是否正常。
>
> **5. 用户体验测试：**
>
> - 界面布局：
>
>   - 测试登录界面的布局是否合理、美观。
>   - 测试提示信息是否清晰、易懂。
>
> - 易用性：
>
>   - 测试登录界面是否易于使用。
>
>   
>
> **Q：对一个接口编写测试用例**
>
> **1. 功能性测试：**
>
> - 正常场景：
>   - 使用正确的参数，验证接口是否返回预期的结果。
>   - 验证接口返回的数据结构是否正确。
>   - 验证接口返回的数据类型是否正确。
> - 异常场景：
>   - 使用错误的参数类型，验证接口是否返回错误提示。
>   - 使用缺失的必填参数，验证接口是否返回错误提示。
>   - 使用超出范围的参数值，验证接口是否返回错误提示。
>   - 使用无效的参数值，验证接口是否返回错误提示。
>   - 测试错误的token验证，查看返回的错误信息。
> - 边界值测试：
>   - 测试参数的边界值，验证接口是否正确处理。
>   - 测试超长字符的参数，验证接口是否正确处理。
> - 业务逻辑测试：
>   - 验证接口是否按照业务规则正确处理数据。
>   - 验证接口是否正确处理各种业务场景。
> - 数据一致性：
>   - 测试接口操作后，数据库的数据是否一致。
>
> **2. 性能测试：**
>
> - 响应时间：
>   - 测试接口在正常负载下的响应时间。
>   - 测试接口在高负载下的响应时间。
> - 并发测试：
>   - 测试接口在高并发情况下的性能。
> - 压力测试：
>   - 测试接口在极限负载下的性能。
>
> **3. 安全性测试：**
>
> - 身份验证：
>   - 验证接口是否需要身份验证。
>   - 验证接口是否使用安全的身份验证机制。
> - 权限控制：
>   - 验证接口是否正确控制用户权限。
>   - 验证未授权用户是否无法访问接口。
> - 数据加密：
>   - 验证接口是否对敏感数据进行加密。
>   - 测试SQL注入，XSS攻击等。
> - 参数校验：
>   - 测试接口对于参数的校验，是否对于异常参数都做了过滤。
>
> **4. 兼容性测试：**
>
> - 不同协议：
>   - 验证接口是否支持不同的协议（如 HTTP、HTTPS）。
> - 不同格式：
>   - 验证接口是否支持不同的数据格式（如 JSON、XML）。
> - 不同环境：
>   - 验证接口在不同环境（如开发环境、测试环境、生产环境）下的兼容性。
>
> **5. 异常测试：**
>
> - 网络异常：
>   - 测试接口在网络异常情况下的表现。
> - 服务器异常：
>   - 测试接口在服务器异常情况下的表现。
> - 数据库异常：
>   - 测试数据库异常情况下，接口的表现。
>
> **测试用例设计：**
>
> - 针对每个测试点，设计详细的测试用例，包括测试步骤、预期结果、实际结果等。
> - 测试用例需要覆盖正常情况、异常情况、边界值等。



#### 进程/线程

> **Q：进程与线程的区别？**
>
> **1. 进程：**
>
> - 想象一下，进程就像一个独立的工厂。这个工厂有自己的土地、机器和工人，可以独立生产产品。
> - 每个工厂（进程）之间是完全分开的，一个工厂出问题，不会影响其他工厂。
> - 因为每个工厂都有自己的全部资源，所以开一个新工厂（启动一个新进程）会比较耗费资源。
>
> **2. 线程：**
>
> - 线程就像工厂里的工人。他们共享工厂的机器和资源，一起协作完成生产任务。
> - 同一个工厂里的工人（线程）可以很容易地互相交流和共享信息。
> - 但是，如果一个工人（线程）出了问题，可能会影响到整个工厂的生产。
> - 因为工人（线程）共享资源，所以增加工人（创建新线程）相对来说更省资源。
>
> **1. 定义与本质：**
>
> - 进程（Process）：
>   - 是操作系统进行资源分配的基本单位。
>   - 是程序在数据集上的一次执行过程，是系统进行资源分配和调度的独立单位。
>   - 拥有独立的内存空间和系统资源。
> - 线程（Thread）：
>   - 是操作系统进行运算调度的最小单位。
>   - 是进程中的一个执行单元，是进程中一条独立的执行路径。
>   - 共享所属进程的内存空间和系统资源。
>
> **2. 资源占用与开销：**
>
> - 进程：
>   - 拥有独立的地址空间，因此进程切换的开销较大。
>   - 占用较多的系统资源。
> - 线程：
>   - 共享进程的地址空间，线程切换的开销较小。
>   - 占用较少的系统资源，被称为轻量级进程。
>
> **3. 包含关系：**
>
> - 一个进程至少包含一个线程，即主线程。
> - 一个进程可以包含多个线程，这些线程并发执行，提高程序的执行效率。
>
> **4. 独立性与影响：**
>
> - 进程：
>   - 进程之间相互独立，一个进程的崩溃不会影响其他进程。
>   - 具有更高的健壮性。
> - 线程：
>   - 同一进程内的线程共享内存空间，一个线程的崩溃可能导致整个进程崩溃。
>   - 相比进程，线程的健壮性稍差。
>
> **5. 数据共享：**
>
> - 进程：
>   - 进程间数据共享需要使用特定的通信机制（如管道、消息队列）。
> - 线程：
>   - 同一进程内的线程可以方便地共享数据。
>
> **Q：何时cpu处理进程最慢？**
>
> **1. 上下文切换频繁：**
>
> - 当操作系统需要在多个进程之间频繁切换时，会发生上下文切换。
> - 上下文切换需要保存和恢复进程的状态，这会消耗大量的CPU资源，导致实际执行进程的时间减少。
> - 如果进程数量过多或进程的I/O操作频繁，就会导致上下文切换过于频繁，从而降低CPU的效率。
>
> **2. 进程阻塞：**
>
> - 当进程需要等待某个事件（如I/O操作完成、资源可用）时，会进入阻塞状态。
> - 在阻塞期间，进程无法使用CPU，CPU只能执行其他进程。
> - 如果大量进程同时阻塞，CPU的利用率就会降低。
>
> **3. 资源竞争：**
>
> - 当多个进程竞争共享资源（如内存、磁盘、网络）时，可能会发生资源竞争。
> - 资源竞争会导致进程互相等待，从而降低CPU的效率。
> - 死锁是资源竞争的一种极端情况，会导致进程永远无法继续执行。
>
> **4. 缓存未命中：**
>
> - CPU的缓存可以提高数据访问速度。
> - 当进程需要访问的数据不在缓存中时，就会发生缓存未命中。
> - 缓存未命中会导致CPU需要从内存或磁盘中读取数据，这会消耗大量时间。
> - 如果进程访问的数据局部性较差，就会导致缓存未命中率较高，从而降低CPU的效率。
>
> **5. 优先级反转：**
>
> - 当高优先级进程需要等待低优先级进程释放资源时，可能会发生优先级反转。
> - 优先级反转会导致高优先级进程被阻塞，从而降低CPU的效率。
>
> 
>
> **Q：为什么会出现死锁？**
>
> 死锁是指两个或多个进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。死锁是一种计算机科学中的状态，在这种状态下，每个成员都在等待其他成员（包括其自身）完成，因此所有成员都永久处于等待状态。
>
> 简单来说，死锁就像是多个人在狭窄的过道里互相堵住，每个人都想先通过，但谁也不愿意让步，结果谁也走不了。
>
> **死锁产生的原因：**
>
> 死锁的产生通常需要同时满足以下四个必要条件：
>
> 1. 互斥条件：
>    - 资源只能被一个进程占用，其他进程请求该资源时只能等待。
>    - 例如，打印机、磁带驱动器等。
> 2. 请求与保持条件：
>    - 进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占用。
>    - 例如，进程A占用了资源1，又请求资源2，而资源2被进程B占用。
> 3. 不可剥夺条件：
>    - 进程已获得的资源，在未使用完之前，不能被其他进程强行剥夺，只能由获得该资源的进程自己释放。
> 4. 循环等待条件：
>    - 存在一种进程资源的循环等待链，链中的每一个进程都在等待下一个进程所占有的资源。
>    - 例如，进程A等待进程B占有的资源，进程B等待进程C占有的资源，进程C等待进程A占有的资源。
>
> 
>
> **Q：进程间通信的方式？**
>
> 进程间通信（IPC）是指不同进程之间交换信息的过程。由于进程具有独立的内存空间，直接访问其他进程的内存是不允许的，因此需要使用特定的机制来实现进程间通信
>
> **1. 管道（Pipes）：**
>
> - 匿名管道（Anonymous Pipes）：
>   - 只能用于具有亲缘关系的进程（如父子进程）之间。
>   - 数据只能单向流动。
> - 命名管道（Named Pipes/FIFO）：
>   - 允许无亲缘关系的进程之间通信。
>   - 数据也可以单向或双向流动。
>
> **2. 消息队列（Message Queues）：**
>
> - 允许进程以消息的形式发送和接收数据。
> - 消息队列提供了一种异步通信机制，发送进程不需要等待接收进程的响应。
>
> **3. 信号量（Semaphores）：**
>
> - 用于进程间的同步和互斥。
> - 信号量可以控制对共享资源的访问，防止多个进程同时修改共享数据。
>
> **4. 共享内存（Shared Memory）：**
>
> - 允许多个进程访问同一块物理内存。
> - 共享内存是速度最快的IPC方式，但需要额外的同步机制来避免数据竞争。
>
> **5. 信号（Signals）：**
>
> - 用于通知进程发生了某个事件。
> - 信号是一种异步通信机制，进程可以在任何时候接收信号。
>
> **6. 套接字（Sockets）：**
>
> - 允许不同计算机上的进程之间通信。
> - 套接字是一种通用的网络通信机制，也适用于本地进程间通信。
>
> 
>
> **Q：线程间通信的方式？**
>
> 线程间通信（Inter-Thread Communication，ITC）是指在同一个进程内的多个线程之间交换信息的过程。由于线程共享进程的内存空间，线程间通信相对进程间通信更加高效和方便。以下是一些常见的线程间通信方式：
>
> **1. 共享内存（Shared Memory）：**
>
> - 多个线程可以直接访问同一块内存区域。
> - 这是最快的线程间通信方式，但需要额外的同步机制来避免数据竞争。
> - 需要使用锁、信号量等同步机制来保证数据的一致性。
>
> **2. 互斥锁（Mutexes）：**
>
> - 用于保护共享资源，确保同一时间只有一个线程可以访问该资源。
> - 线程在访问共享资源之前需要获取互斥锁，访问完成后释放互斥锁。
> - 可以防止多个线程同时修改共享数据，导致数据错误。
>
> **3. 条件变量（Condition Variables）：**
>
> - 允许线程在满足特定条件时等待，并在条件满足时被唤醒。
> - 条件变量通常与互斥锁一起使用，用于实现线程的同步和协作。
> - 可以用于实现生产者-消费者模型等复杂的线程间通信场景。
>
> **4. 信号量（Semaphores）：**
>
> - 用于控制对共享资源的访问，允许多个线程同时访问资源，但限制同时访问的线程数量。
> - 信号量可以用于实现线程的同步和互斥。
> - 可以用于实现资源池等场景。
>
> **5. 消息队列（Message Queues）：**
>
> - 允许线程以消息的形式发送和接收数据。
> - 消息队列提供了一种异步通信机制，发送线程不需要等待接收线程的响应。
> - 可以用于实现线程间的解耦和异步通信。
>
> **6. 管道（Pipes）：**
>
> - 分为匿名管道和命名管道。
> - 匿名管道只能用于父子线程或者兄弟线程之间通信。
> - 命名管道可以用于任意线程之间通信。
>
> 
>
> **Q：如何做到线程同步？**
>
> 线程同步是多线程编程中一个至关重要的概念，它确保了多个线程在访问共享资源时能够协调工作，避免数据竞争和不一致性。以下是一些实现线程同步的常用方法：
>
> **1. 互斥锁（Mutex）：**
>
> - 互斥锁是最基本的同步机制，它确保了在任何时刻只有一个线程可以访问共享资源。
> - 当一个线程尝试获取已被其他线程持有的互斥锁时，它将被阻塞，直到该互斥锁被释放。
> - 互斥锁适用于保护对共享资源的独占访问。
>
> **2. 条件变量（Condition Variable）：**
>
> - 条件变量允许线程在满足特定条件时等待，并在条件满足时被唤醒。
> - 条件变量通常与互斥锁一起使用，用于实现线程的同步和协作。
> - 当线程需要等待某个条件满足时，它会释放互斥锁并进入等待状态。
> - 当其他线程改变了条件并发送信号时，等待的线程将被唤醒，并重新获取互斥锁。
>
> **3. 信号量（Semaphore）：**
>
> - 信号量是一种更通用的同步机制，它可以控制对共享资源的访问数量。
> - 信号量维护一个计数器，表示可用资源的数量。
> - 线程在访问共享资源之前需要获取信号量，如果计数器大于 0，则获取成功，计数器减 1；否则，线程将被阻塞。
> - 线程在释放共享资源时，会释放信号量，计数器加 1。
>
> **4. 读写锁（Read-Write Lock）：**
>
> - 读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。
> - 读写锁适用于读多写少的场景，可以提高并发性能。
> - 读写锁有两种状态：读模式和写模式。
> - 多个线程可以同时获取读模式的读写锁，但只有一个线程可以获取写模式的读写锁。
>
> **5. 原子操作（Atomic Operations）：**
>
> - 原子操作是不可中断的操作，它可以确保在多线程环境下对共享数据的访问是安全的。
> - 原子操作通常由硬件提供支持，可以避免使用互斥锁带来的性能开销。
> - 原子操作适用于简单的计数器、标志位等共享数据的访问。
>
> **6. 屏障（Barrier）：**
>
> - 屏障允许一组线程在所有线程都到达屏障点之前等待。
> - 当所有线程都到达屏障点时，它们将被同时唤醒，继续执行。
> - 屏障适用于需要多个线程协同工作的场景。



#### Linux

> **Q：linux切换目录**
>
> cd 
>
> **Q：linux命令，统计一个文本中关键字出现的次数**
>
> `-o` 选项表示只输出匹配到的关键字，而不是整行。
>
> grep -o "关键字" 文件名 | wc -l
>
> **Q：linux 查找当前目录下所有后缀为 .py文件**
>
> find . -name "*.py"
>
> ls *.py
>
> **Q：知道的linux常用命令：查看指定端口进程**
>
> ```
> netstat -tunlp | grep 端口号
> ```
>
> 参数说明：
>
> - `-t`：显示 TCP 连接。
> - `-u`：显示 UDP 连接。
> - `-n`：以数字形式显示地址和端口号。
> - `-l`：显示监听状态的套接字。
> - `-p`：显示进程 ID 和进程名称。
> - `grep 端口号`：过滤出包含指定端口号的行
>
> **Q：cd - 和 cd ～**
>
> `cd ~`：始终切换到用户主目录。
>
> `cd -`：切换到上一个工作目录。
>
> **Q：linux 查看某个进程命令怎么写**
>
> ```
> ps aux | grep 进程名称
> ```
>
> - `aux`：显示所有用户的进程，包括没有控制终端的进程。
> - `|`：管道符号，将 `ps` 命令的输出传递给 `grep` 命令。
> - `grep 进程名称`：过滤出包含指定进程名称的行。
>
> ```
> ps -p PID
> ```
>
> - `-p PID`：显示指定 PID 的进程。
>
> **Q：如何查看日志？怎么查看后500条日志？**
>
> **`tail -n`：**
>
> - `tail -n` 命令可以指定显示的行数。
> - 示例：`tail -n 500 /var/log/syslog`
> - 这个命令可以显示syslog这个日志文件的最后500行。
>
> **结合 `less`：**
>
> - `tail -n 500 /var/log/syslog | less`
> - 这个命令可以将日志文件的最后500行，通过管道命令'|'传递给less命令，然后通过less命令进行分页显示，这样可以更方便的翻阅日志。
>
> 
>
> **Q：awk有什么用？如何用（举个例子）？**
>
> `awk` 是一种强大的文本处理工具，它允许你以灵活的方式提取、转换和格式化文本数据。
>
> ```
> awk '模式 {动作}' 文件名
> ```
>
> - **模式：** 用于匹配文本行的规则，例如正则表达式、条件表达式等。
> - **动作：** 在匹配到的文本行上执行的操作，例如打印、计算、赋值等。
>
> 
>
> 假设有一个名为 `data.txt` 的文本文件，内容如下：
>
> ```
> apple 10 2.5
> banana 5 1.8
> orange 8 3.2
> ```
>
> 1. 提取第一列和第三列：
>
> Bash
>
> ```shell
> awk '{print $1, $3}' data.txt
> ```
>
> **Q：如何查看系统性能？**
>
> **top/htop：** 实时显示系统进程和资源使用情况。`htop` 是 `top` 的增强版本，提供更友好的界面。
>
> **vmstat：** 显示虚拟内存、进程、CPU 活动和 I/O 等信息。
>
> **iostat：** 显示磁盘 I/O 统计信息。
>
> **free：** 显示内存使用情况。
>
> **df/du：** 显示磁盘空间使用情况。
>
> **netstat/ss：** 显示网络连接和统计信息。
>
> **Q：如何查看剩余磁盘空间大小？**
>
> 
>
> **Q：如何查看目录占空间大小？**
>
> **df/du：** 显示磁盘空间使用情况。
>
> du -sh .
>
> `du`：命令本身。
>
> `-s`：汇总显示，只显示总计。
>
> `-h`：以人类可读的格式显示（例如，KB、MB、GB）。
>
> `.`：表示当前目录。
>
> 
>
> **Q：测试服务器之间怎么进行文件拷贝？**
>
> 从本地服务器拷贝到远程服务器：
>
> Bash
>
> ```
> scp /path/to/local/file username@remote_server_ip:/path/to/remote/directory
> ```
>
> 从远程服务器拷贝到本地服务器：
>
> Bash
>
> ```
> scp username@remote_server_ip:/path/to/remote/file /path/to/local/directory
> ```
>
> 拷贝文件夹需要添加 -r 参数
>
> Bash
>
> ```
> scp -r /path/to/local/file username@remote_server_ip:/path/to/remote/directory
> ```
>
> 
>
> **Q：sed 有什么用？如何用（举个例子）？**
>
> `sed`（Stream Editor）是一种强大的文本处理工具，它允许你对文本进行搜索、替换、删除和插入等操作。`sed` 以行为单位处理文本，非常适合处理大型文件。
>
> ```
> sed '命令' 文件名
> ```
>
> - **命令：** 指定要执行的操作，例如 `s`（替换）、`d`（删除）、`a`（追加）、`i`（插入）、`p`（打印）等。
>
> **常用命令和选项：**
>
> - **`s/旧字符串/新字符串/g`：** 替换命令，`g` 表示全局替换。
> - **`d`：** 删除命令。
> - **`-i`：** 直接修改文件内容（默认情况下，`sed` 只输出修改后的内容，不修改原文件）。
> - **`-n`：** 静默模式，只输出匹配到的行。
>
> 
>
> **Q：怎么杀死一个进程？**
>
>  **使用 `kill` 命令（基本方法）：**
>
> - `kill` 命令用于向进程发送信号，其中最常用的信号是 `SIGTERM`（终止）和 `SIGKILL`（强制终止）。
>
>   - **终止进程（SIGTERM）：**
>
>     Bash
>
>     ```
>     kill PID
>     ```
>
>     或者
>
>     Bash
>
>     ```
>     kill -15 PID
>     ```
>
>     - `PID`：要终止的进程的 PID。
>     - 这是默认的终止信号，它允许进程在终止前进行清理工作。
>
>   - **强制终止进程（SIGKILL）：**
>
>     Bash
>
>     ```
>     kill -9 PID
>     ```
>
> 使用 `kill -9` 强制终止进程可能会导致数据丢失或系统不稳定。
>
> 在终止系统关键进程之前，请务必小心。
>
> 
>
> **Q：怎么递归删除一个目录下的所有文件？**
>
> ```
> rm -rf 目录路径
> ```
>
> - `rm`：删除文件或目录的命令。
> - `-r`：递归删除目录及其内容。
> - `-f`：强制删除，不提示确认。
> - `目录路径`：要删除的目录的路径。
>
> 
>
> **Q：怎么查看内存大小？**
>
> 
>
> **Q：怎么查看 CPU 使用情况？**
>
> top
>
> **Q：怎么重启 Linux 服务器？**
>
> **. 使用 `reboot` 命令：**
>
> - `reboot` 命令会立即重启服务器。
>
> - 这是最常用的重启命令，适用于大多数情况。
>
> - 命令格式：
>
>   Bash
>
>   ```
>   sudo reboot
>   ```
>
> - 需要 `sudo` 权限才能执行。
>
> **2. 使用 `shutdown` 命令：**
>
> - `shutdown` 命令提供了更灵活的重启选项。
>
> - 你可以指定重启时间，并向所有登录用户发送警告信息。
>
> - 命令格式：
>
>   Bash
>
>   ```
>   sudo shutdown -r now
>   ```
>
>   - `-r`：表示重启。
>   - `now`：表示立即重启。
>   - 你也可以指定一个时间，例如 `sudo shutdown -r +10` 表示 10 分钟后重启。
>
> 
>
> **Q：怎么打印出一个文件的第500-1000行？**
>
> sed -n '500,1000p' 文件名
>
> `-n`：静默模式，只输出匹配到的行。
>
> `'500,1000p'`：指定要打印的行范围，`p` 表示打印。



#### 非关系型数据库

> **Q：非关系型数据库有哪些？**
>
> redis、mongodb、es
>
> **Q：Redis的数据结构有哪些？**
>
> **1. 字符串（String）：**
>
> - 字符串是 Redis 中最基本的数据结构，它可以存储文本、数字或二进制数据。
> - 字符串类型的值实际可以是字符串（简单和复杂字符串，例如JSON、XML）、数值（整数、浮点数），甚至是二进制（图片、音频、视频），不过值最大不能超过512MB。
> - 字符串常用操作：`SET`、`GET`、`DEL`、`INCR`、`DECR` 等。
>
> **2. 列表（List）：**
>
> - 列表是一个有序的字符串集合，可以在列表的两端进行插入和删除操作。
> - 列表常用操作：`LPUSH`、`RPUSH`、`LPOP`、`RPOP`、`LRANGE` 等。
> - 应用场景：消息队列、最新消息列表等。
>
> **3. 哈希（Hash）：**
>
> - 哈希是一个键值对集合，类似于字典，可以存储对象。
> - 哈希常用操作：`HSET`、`HGET`、`HDEL`、`HGETALL` 等。
> - 应用场景：存储用户信息、对象缓存等。
>
> **4. 集合（Set）：**
>
> - 集合是一个无序的字符串集合，不允许重复元素。
> - 集合常用操作：`SADD`、`SREM`、`SMEMBERS`、`SINTER`、`SUNION` 等。
> - 应用场景：标签系统、社交关系等。
>
> **5. 有序集合（Sorted Set）：**
>
> - 有序集合是一个有序的字符串集合，每个元素都关联一个分数（score），用于排序。
> - 有序集合常用操作：`ZADD`、`ZREM`、`ZRANGE`、`ZSCORE` 等。
> - 应用场景：排行榜、计数器等。
>
> 
>
> **Q：Redis 的用途？**
>
> Redis（Remote Dictionary Server）是一个开源的内存数据结构存储系统，它可以用作数据库、缓存和消息代理。由于其高性能和丰富的数据结构，Redis 在各种应用场景中都有广泛的应用。
>
> 
>
> **Q：Redis一秒能写入多少数据？**
>
> Redis 的写入性能受到多种因素的影响，因此很难给出一个确定的数值。以下是一些影响 Redis 写入性能的关键因素：
>
> 硬件配置、数据大小、网络环境、redis配置
>
> 
>
> **Q：Redis为什么快？**
>
> **1. 基于内存的数据存储：**
>
> - Redis 将所有数据存储在内存中，避免了磁盘 I/O 操作的延迟。
> - 内存读写速度远高于磁盘读写速度，这是 Redis 高性能的基础。
>
> **2. 单线程模型：**
>
> - Redis 的核心处理逻辑是单线程的，避免了多线程上下文切换和锁竞争的开销。
> - 单线程模型简化了代码实现，降低了并发控制的复杂度。
> - Redis 通过异步 I/O 和多路复用技术，在单线程下也能高效处理大量并发请求。
>
> **3. 高效的数据结构：**
>
> - Redis 提供了多种高效的数据结构，如跳跃表、哈希表等，优化了数据访问和操作的性能。
> - 这些数据结构经过精心设计，能够在内存中快速执行各种操作。
>
> **4. I/O 多路复用：**
>
> - Redis 使用 I/O 多路复用技术（如 epoll、select），在一个线程中同时处理多个客户端连接。
> - 这使得 Redis 能够在高并发场景下高效地处理大量请求。
>
> **5. 底层采用 C 语言实现：**
>
> - C 语言是一种高性能的编程语言，Redis 使用 C 语言实现，保证了其底层的高效性。
>
> 
>
> **Q：Redis的过期时间怎么设置？哪些场景适合缓存更长时间？**
>
> **使用 `EXPIRE` 命令（以秒为单位）：**
>
> - `EXPIRE key seconds`：设置 `key` 在 `seconds` 秒后过期。
> - 示例：`EXPIRE mykey 60`（设置 `mykey` 在 60 秒后过期）。
>
> **2. 使用 `PEXPIRE` 命令（以毫秒为单位）：**
>
> - `PEXPIRE key milliseconds`：设置 `key` 在 `milliseconds` 毫秒后过期。
> - 示例：`PEXPIRE mykey 60000`（设置 `mykey` 在 60000 毫秒后过期）。
>
> **3. 使用 `EXPIREAT` 命令（基于时间戳）：**
>
> - `EXPIREAT key timestamp`：设置 `key` 在 `timestamp` 时间戳（Unix 时间戳，以秒为单位）后过期。
> - 示例：`EXPIREAT mykey 1678886400`（设置 `mykey` 在 2023 年 3 月 16 日 00:00:00 UTC 过期）。
>
> **4. 在 `SET` 命令中使用过期选项：**
>
> - `SET key value EX seconds`：设置 `key` 的值为 `value`，并在 `seconds` 秒后过期。
> - `SET key value PX milliseconds`：设置 `key` 的值为 `value`，并在 `milliseconds` 毫秒后过期。
> - 示例：`SET mykey "hello" EX 60`（设置 `mykey` 的值为 "hello"，并在 60 秒后过期）。
>
> **哪些场景适合缓存更长时间？**
>
> - 静态内容：
>   - 例如，网站的静态 HTML 页面、图片、CSS、JavaScript 文件等。
>   - 这些内容很少变化，可以设置较长的过期时间，甚至永久缓存。
> - 不经常变化的数据：
>   - 例如，用户信息、产品信息、配置信息等。
>   - 这些数据更新频率较低，可以设置较长的过期时间。
> - 计算成本高的数据：
>   - 例如，复杂的查询结果、聚合数据、统计数据等。
>   - 这些数据计算成本较高，可以设置较长的过期时间，避免重复计算。
> - 访问频率低的数据：
>   - 例如，历史数据、归档数据等。
>   - 这些数据访问频率较低，可以设置较长的过期时间，减少内存占用。
>
> **设置过期时间需要考虑的因素：**
>
> - **数据更新频率：** 数据更新越频繁，过期时间应该设置得越短。
> - **数据重要性：** 重要数据应该设置较短的过期时间，确保数据的实时性。
> - **缓存大小：** 缓存空间有限，过期时间过长可能导致缓存溢出。
> - **业务需求：** 根据具体的业务需求，设置合适的过期时间。
>
> 
>
> **Q：什么是缓存雪崩？**
>
> 缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，请求直接落到数据库上，引起数据库压力过大甚至宕机。缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。
>
> **使用分布式锁：**
>
> - 在查询数据库时，使用分布式锁来避免并发查询导致的数据库压力增大。
>
> **Redis 集群：**
>
> - 使用 Redis 集群，提高 Redis 服务的可用性，避免单点故障。
>
> **Q：什么是缓存击穿？缓存击穿和缓存穿透的区别是什么？**
>
> 缓存击穿是指一个热点 Key（高并发访问的 Key）在缓存中过期失效，此时大量并发请求直接穿透缓存，全部到达数据库，导致数据库压力骤增，甚至崩溃。
>
> **缓存击穿的特点：**
>
> - **热点 Key：** 击穿通常发生在访问量极高的热点数据上。
> - **缓存失效：** 缓存中的热点数据因过期而失效。
> - **数据库压力：** 大量并发请求直接访问数据库，造成压力。
>
> **缓存击穿和缓存穿透的区别：**
>
> 虽然缓存击穿和缓存穿透都会导致数据库压力增大，但它们之间存在本质区别：
>
> - 缓存穿透：
>   - 指查询根本不存在于缓存和数据库中的数据。
>   - 大量请求不断查询不存在的 Key，导致每次请求都穿透缓存，直接访问数据库。
>   - 这种情况下，缓存形同虚设，数据库压力持续增大。
>   - 根本原因：查询不存在的数据
> - 缓存击穿：
>   - 指查询存在于数据库中，但缓存中已过期失效的热点数据。
>   - 大量并发请求同时查询这个过期失效的 Key，导致请求穿透缓存，直接访问数据库。
>   - 这种情况下，数据库压力在缓存失效的瞬间激增。
>   - 根本原因：热点Key缓存失效
>
> **如何解决缓存击穿：**
>
> - 设置热点 Key 永不过期：
>   - 对于访问量极高的热点数据，可以考虑设置永不过期，或者延长其过期时间。
> - **使用二级缓存：**
>   - 设置一个永不过期的“备份”缓存，当主缓存失效时，先从备份缓存读取数据，然后异步更新主缓存。
>
> 
>
> **Q：Redis 适合做消息队列吗？为什么？**
>
> 可以做消息队列，在需要比较高的性能的情况可以用redis来做消息队列
>
> **Q：Redis 的数据是存储在内存当中的，假如断电之后就会造成数据丢失，那怎么对 Redis 进行数据固化？**
>
> Redis 提供了两种主要的数据持久化机制，可以将内存中的数据固化到磁盘上：RDB，



#### 数据库基本理论

> **Q：有哪些数据库优化的方式？**
>
> 读写分离、批量操作、升级硬件
>
> **索引优化：**
>
> - 创建合适的索引：
>   - 在经常用于查询条件的列上创建索引。
>   - 注意避免创建过多索引，因为索引会增加写操作的开销。
> - 优化索引：
>   - 定期分析索引使用情况，删除不必要的索引。
>   - 考虑使用复合索引，优化多列查询。
> - 避免索引失效：
>   - 避免在 where 子句中对字段进行函数操作，这会导致索引失效。
>
> **SQL 查询优化：**
>
> - 避免使用 SELECT *：
>   - 只查询需要的列，减少数据传输量。
> - 优化 WHERE 子句：
>   - 尽量使用索引列作为查询条件。
>   - 避免在 WHERE 子句中使用 OR，可以使用 UNION 或 IN 替代。
> - 优化 JOIN 查询：
>   - 尽量使用 INNER JOIN，避免使用全外连接。
>   - 确保 JOIN 的列上有索引。
> - 使用 EXPLAIN 分析查询：
>   - 通过 EXPLAIN 分析查询执行计划，找出性能瓶颈。
>
> **缓存优化：**
>
> - 使用数据库缓存：
>   - 利用数据库自身的查询缓存。
> - 使用外部缓存：
>   - 使用 Redis、Memcached 等外部缓存，减轻数据库压力。
>
> 
>
> **Q：关系型数据库和非关系型数据库的区别？**
>
> ![image-20250303122945176](C:\Users\AlanHuang\Desktop\assets\image-20250303122945176.png)
>
> **Q：数据库的事务有什么用？什么时候应该使用事务，什么时候不该使用事务？**
>
> 数据库事务是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。事务的目的是为了保证数据库操作的原子性、一致性、隔离性和持久性（ACID），确保数据在并发访问和系统故障时保持正确状态。
>
> **事务的四大特性（ACID）：**
>
> - **原子性（Atomicity）：** 事务是一个不可分割的操作序列，要么全部执行成功，要么全部不执行。
> - **一致性（Consistency）：** 事务执行前后，数据库必须保持一致性状态。
> - **隔离性（Isolation）：** 并发执行的事务之间相互隔离，一个事务的执行不应影响其他事务。
> - **持久性（Durability）：** 已提交的事务的修改是永久性的，即使系统发生故障也不会丢失。
>
> **事务的用途：**
>
> - **保证数据完整性：** 在复杂操作中，确保数据的一致性和正确性。
> - **并发控制：** 在多用户并发访问数据库时，防止数据冲突和错误。
> - **错误恢复：** 在事务执行过程中发生错误时，回滚事务，保证数据回到初始状态。
>
> **何时应该使用事务：**
>
> - **涉及多个相关操作：** 当一个业务操作涉及多个数据库操作时，应该使用事务保证这些操作的原子性。例如，银行转账，需要同时更新两个账户的余额。
> - **需要保证数据一致性：** 当业务操作需要保证数据在任何情况下都保持一致性时，应该使用事务。例如，订单处理，需要同时更新订单表、商品表和库存表。
> - **并发访问频繁：** 当多个用户同时访问和修改同一份数据时，应该使用事务保证数据的隔离性和一致性。例如，在线购物网站的库存管理。
>
> **何时不该使用事务：**
>
> - **简单的查询操作：** 如果只是简单的查询数据库，不需要修改数据，则不需要使用事务。
> - **只读操作：** 如果只是读取数据库中的数据，不需要修改数据，则不需要使用事务。
> - **对性能要求极高：** 事务会带来一定的性能开销。在对性能要求极高的场景下，可以考虑牺牲部分数据一致性，不使用事务。
> - **数据量非常大的批量操作：** 对于数据量非常大的批量操作，如果使用事务，可能会导致事务执行时间过长，影响数据库性能。可以考虑将批量操作拆分成多个小事务，或者使用其他优化手段。
>
> 
>
> **Q：数据库索引有什么用？什么是联合索引？**
>
> 数据库索引是一种数据结构，用于提高数据库查询的速度。它类似于书籍的目录，可以帮助数据库快速定位到包含特定数据的行，而无需扫描整个表。
>
> **数据库索引的作用：**
>
> - 加速查询：
>   - 索引可以显著减少数据库需要扫描的数据量，从而提高查询速度。
>   - 对于包含大量数据的表，索引的优势尤为明显。
> - 保证数据唯一性：
>   - 唯一索引可以确保表中的某一列或多列的值是唯一的。
>   - 这有助于维护数据的完整性。
> - 加速排序和分组：
>   - 索引可以按照特定的顺序存储数据，从而加速排序和分组操作。
>
> **什么是联合索引？**
>
> 联合索引（也称为复合索引或组合索引）是指由多个列组合而成的索引。与单列索引只针对单个列进行索引不同，联合索引可以同时对多个列进行索引，以提高多列查询的性能。
>
> **联合索引的特点：**
>
> - 多列组合：
>   - 联合索引包含多个列，这些列按照特定的顺序组合在一起。
> - 最左前缀原则：
>   - 联合索引遵循最左前缀原则，这意味着查询条件必须包含联合索引的最左边的列，才能使用该索引。
>   - 例如，如果有一个联合索引 (A, B, C)，那么查询条件包含 A、(A, B) 或 (A, B, C) 时，可以使用该索引。
>   - 但是，查询条件只包含 B 或 C 时，无法使用该索引。
> - 提高多列查询性能：
>   - 联合索引可以显著提高多列查询的性能，特别是当查询条件包含联合索引的所有列或最左边的列时。
>
> **联合索引的优势：**
>
> - 减少 I/O 操作：
>   - 联合索引可以将多个列的数据存储在一起，减少数据库需要读取的数据块数量，从而减少 I/O 操作。
> - 覆盖索引：
>   - 如果查询只需要访问联合索引中包含的列，那么数据库可以直接从索引中获取数据，而无需访问数据表，从而提高查询速度。
> - 提高排序和分组性能：
>   - 联合索引可以按照特定的顺序存储数据，从而加速排序和分组操作。
>
> **联合索引的注意事项：**
>
> - 索引列的顺序：
>   - 联合索引的性能与索引列的顺序密切相关。
>   - 应该将最常用的查询条件放在联合索引的最左边。
> - 索引列的数量：
>   - 联合索引包含的列越多，索引的大小就越大，从而增加存储空间和维护成本。
>   - 应该根据实际需求选择合适的索引列数量。
> - 索引维护成本：
>   - 索引会增加写操作的开销，因为每次插入、更新或删除数据时，都需要更新索引。
>   - 应该避免创建过多索引。
>
> 
>
> **Q：主键适合用自定义ID还是自动ID？**
>
> **小型应用或单体应用：**
>
> - 如果应用规模较小，对性能要求较高，且不需要全局唯一性，建议使用自动 ID。
>
> **分布式应用或微服务：**
>
> - 如果应用需要全局唯一性，或者需要在多个数据库之间进行数据整合，建议使用自定义 ID。
>
> **安全性要求高的应用：**
>
> - 如果对安全性要求较高，建议使用自定义 ID。
>
> **数据迁移频繁的应用：**
>
> - 如果数据迁移或表合并频繁，建议使用自定义 ID。
>
> 
>
> **Q：外键是什么？为什么大公司有时候不建议使用外键？**
>
> 外键（Foreign Key）是关系型数据库中用于建立和加强两个表数据之间链接的一种机制。外键约束确保了数据的一致性和完整性。然而，在大规模、高并发的系统中，外键的使用可能会带来一些性能和维护上的挑战，这也是为什么一些大公司在特定情况下不建议使用外键的原因。
>
> 
>
> **Q：索引设置得越多越好吗？索引得优缺点是什么？**
>
> 并不是
>
> **选择合适的列：**
>
> - 在经常用于查询条件的列上创建索引。
> - 在经常用于排序和分组的列上创建索引。
>
> 优点：加速查询、缺点：增加存储空间占用、可能会索引失效
>
> 
>
> **Q：为什么会造成数据库死锁？怎么解决？**
>
> 数据库死锁是指两个或多个事务在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法继续推进下去。
>
> **造成数据库死锁的原因：**
>
> 1. 资源竞争：
>    - 多个事务试图同时访问相同的资源（如数据库表、行、页或锁），但它们请求资源的顺序不同，导致相互等待。
> 2. 未释放资源：
>    - 事务在使用完资源后未及时释放，导致其他事务无法获得所需的资源。
>    - 这可能是由于程序错误或异常情况引起的。
> 3. 事务隔离级别：
>    - 较高的事务隔离级别（如可串行化）会增加死锁的风险，因为它们会使用更严格的锁定策略。
> 4. 锁定顺序：
>    - 如果多个事务以不同的顺序锁定资源，可能会导致死锁。
>    - 例如，事务 A 先锁定资源 1，再请求资源 2；而事务 B 先锁定资源 2，再请求资源 1。
>
> **解决数据库死锁的方法：**
>
> 1. 避免死锁的发生：
>    - 优化事务设计：
>      - 尽量减少事务的持有锁的时间，减少事务的范围。
>      - 尽量避免在同一事务中访问多个资源。
>      - 使用较低的事务隔离级别。
>    - 统一资源访问顺序：
>      - 确保所有事务都以相同的顺序访问资源，避免循环等待。
>    - 使用索引：
>      - 合理的索引可以减少锁定范围，降低死锁的概率。
>    - 设置锁超时：
>      - 为锁设置超时时间，当事务等待锁的时间超过阈值时，自动释放锁。
> 2. 检测和解决死锁：
>    - 死锁检测：
>      - 数据库系统通常会自动检测死锁，并选择一个事务进行回滚，释放其持有的锁。
>    - 应用程序处理：
>      - 在应用程序中捕获死锁异常，并进行重试或回滚。
>      - 记录死锁日志，用于分析和优化。
> 3. 数据库配置优化：
>    - 调整死锁检测间隔：
>      - 根据实际情况调整死锁检测的频率。
>    - 调整锁等待超时时间：
>      - 设置合理的锁等待超时时间，避免长时间的等待。
>
> 
>
> **Q：事务都有哪些特点？**
>
> **原子性（Atomicity）**
>
> - 原子性意味着事务是一个不可分割的最小工作单元，事务中的所有操作要么全部成功执行，要么全部不执行。
> - 如果事务中的任何一个操作失败，整个事务都会回滚到事务开始之前的状态，就像事务从未发生过一样。
> - 这确保了事务的完整性，防止数据处于不一致的中间状态。
>
> **2. 一致性（Consistency）**
>
> - 一致性确保事务在执行前后，数据库从一个一致性状态转变到另一个一致性状态。
> - 事务必须遵守预定义的规则和约束，如主键约束、外键约束、唯一性约束等。
> - 一致性不仅指数据库的物理完整性，还包括业务逻辑上的完整性。
>
> **3. 隔离性（Isolation）**
>
> - 隔离性是指并发执行的事务之间应该相互隔离，一个事务的执行不应该影响其他事务的执行。
> - 不同的事务隔离级别定义了事务之间可见性的程度，常见的隔离级别包括读未提交、读已提交、可重复读和串行化。
> - 隔离性保证了并发环境下数据的正确性和一致性。
>
> **4. 持久性（Durability）**
>
> - 持久性意味着一旦事务提交，其所做的修改就会永久保存在数据库中，即使系统发生故障也不会丢失。
> - 通常通过事务日志（如 redo log）来实现持久性，确保事务提交后数据能够恢复。
> - 持久性保证了数据的可靠性和安全性。
>
> 
>
> **Q：数据库设计的三大范式是什么？**
>
> 第一范式（1NF）：强调的是列的原子性，即列不能够再拆分。
>
> 第二范式（2NF）：强调的是表中的列必须完全依赖于主键。
>
> 第三范式（3NF）：强调的是表中的列之间不能存在传递依赖。
>
> 
>
> **Q：为什么要进行分表分库？**
>
> 分库分表是一种数据库优化策略，它通过将大型数据库或表分割成更小、更易于管理的部分，从而提高数据库的性能、可扩展性和可用性。以下是进行分库分表的主要原因：
>
> **1. 解决性能瓶颈：**
>
> - 数据量过大：
>   - 当单表数据量达到千万甚至亿级别时，查询、插入、更新等操作的性能会明显下降。
>   - 分表可以将数据分散到多个表中，减少单个表的负担，提高查询速度。
> - 并发量过高：
>   - 高并发访问时，单个数据库可能无法承受巨大的压力，导致响应缓慢甚至崩溃。
>   - 分库可以将请求分散到多个数据库上，提高系统的并发处理能力。



#### SQL

> **Q：【手撕】数据库，查找一个学生两门功课都大于80分的姓名**
>
> - Students 表：
>   - `StudentID` (INT, 主键)
>   - `Name` (VARCHAR)
> - Scores 表：
>   - `StudentID` (INT, 外键，关联 Students.StudentID)
>   - `Course` (VARCHAR, 课程名称)
>   - `Score` (INT, 分数)
>
> ```sql
> SELECT s.Name
> FROM Students s
> JOIN Scores sc1 ON s.StudentID = sc1.StudentID
> JOIN Scores sc2 ON s.StudentID = sc2.StudentID
> WHERE sc1.Course = '课程1' AND sc1.Score > 80
>   AND sc2.Course = '课程2' AND sc2.Score > 80;
> ```
>
> 
>
> **Q：【手撕】联表查询2个表中工号为“123”的人的所有信息**
>
> - Employees 表：
>
>   - `EmployeeID` (INT, 主键, 工号)
>
>   - `Name` (VARCHAR, 姓名)
>
>   - `DepartmentID` (INT, 外键, 部门ID)
>
>   - `Position` (VARCHAR, 职位)
>
>   - `Salary` (DECIMAL, 工资)
>
> - Departments 表：
>   - `DepartmentID` (INT, 主键, 部门ID)
>   - `DepartmentName` (VARCHAR, 部门名称)
>   - `Location` (VARCHAR, 部门位置)
>
> ```sql
> SELECT *
> FROM Employees e
> JOIN Departments d ON e.DepartmentID = d.DepartmentID
> WHERE e.EmployeeID = '123';
> ```
>
> 
>
> **Q：【手撕】一个人员表，一个部门表，人员表中存了部门id，查人员表各部门表所有数据**
>
> - 人员表 (Employees):
>   - `EmployeeID` (INT, 主键, 人员ID)
>   - `Name` (VARCHAR, 姓名)
>   - `DepartmentID` (INT, 外键, 部门ID)
>   - `Position` (VARCHAR, 职位)
> - 部门表 (Departments):
>   - `DepartmentID` (INT, 主键, 部门ID)
>   - `DepartmentName` (VARCHAR, 部门名称)
>   - `Location` (VARCHAR, 部门位置)
>
> **1. 使用 INNER JOIN（内连接）：**
>
> - `INNER JOIN` 只返回两个表中匹配的行，即只有在人员表和部门表都有对应 `DepartmentID` 的记录才会显示。
>
> ```sql
> SELECT *
> FROM Employees e
> INNER JOIN Departments d ON e.DepartmentID = d.DepartmentID;
> ```
>
> 
>
> **Q：【手撕】查询一个城市列表里面重复的城市名，并且统计重复次数**
>
> 使用 `GROUP BY` 和 `COUNT`
>
> ```
> SELECT CityName, COUNT(*) AS RepeatCount
> FROM Cities
> GROUP BY CityName
> HAVING COUNT(*) > 1;
> ```
>
> 解释：
>
> - `GROUP BY CityName`: 将结果按照 `CityName` 列进行分组。
> - `COUNT(*)`: 统计每个分组中的行数，即重复次数。
> - `HAVING COUNT(*) > 1`: 筛选出重复次数大于 1 的城市名。
>
> 
>
> **Q：【手撕】查找一个学生成绩表中平均分数大于90分的学生名单**
>
> - Students 表：
>   - `StudentID` (INT, 主键)
>   - `Name` (VARCHAR, 姓名)
> - Scores 表：
>   - `StudentID` (INT, 外键，关联 Students.StudentID)
>   - `Course` (VARCHAR, 课程名称)
>   - `Score` (INT, 分数)
>
> ```sql
> SELECT s.Name
> FROM Students s
> JOIN Scores sc ON s.StudentID = sc.StudentID
> GROUP BY s.StudentID
> HAVING AVG(sc.Score) > 90;
> ```
>
> 
>
> **Q：【手撕】查找学生成绩表中平均成绩最高的同学**
>
> 要查找学生成绩表中平均成绩最高的同学，你需要使用 SQL 查询语句，具体取决于你的数据库结构。假设你有两个表：`Students`（学生表）和 `Scores`（成绩表）。
>
> **假设表结构如下：**
>
> - Students 表：
>   - `StudentID` (INT, 主键)
>   - `Name` (VARCHAR, 姓名)
> - Scores 表：
>   - `StudentID` (INT, 外键，关联 Students.StudentID)
>   - `Course` (VARCHAR, 课程名称)
>   - `Score` (INT, 分数)
>
> ```sql
> SELECT s.Name
> FROM Students s
> JOIN Scores sc ON s.StudentID = sc.StudentID
> GROUP BY s.StudentID
> ORDER BY AVG(sc.Score) DESC
> LIMIT 1;
> ```
>
> 
>
> **Q：删除数据的方式有哪些？说说 drop table和truncate table的区别？**
>
> 1.delete from table, drop table, truncate table
>
> ![image-20250303124558013](C:\Users\AlanHuang\Desktop\assets\image-20250303124558013.png)



#### Python

> **Q：全局变量和局部变量变量名能否一样？**
>
> 
>
> **Q：Python 里 is 和 == 的区别？**
>
> 
>
> **Q：Python 变量的创建与消亡过程**
>
> 
>
> **Q：Python的垃圾回收的机制**
>
> 
>
> **Q：dict的底层结构，tuple和list的底层结构的区别**
>
> 
>
> **Q：深拷贝浅拷贝的区别是什么？**
>
> 
>
> **Q：什么是协程？**
>
> 
>
> **Q：什么是装饰器？举一个你用过装饰器的例子**
>
> 
>
> **Q：@classmethod 和 @staticmethod 的区别，以及分别运用在哪些使用场景？**
>
> 
>
> **Q：什么是鸭子类型？**
>
> 
>
> **Q：python 的可变类型有哪些？**
>
> 
>
> **Q：python 常见的数据类型有哪些？**
>
> 
>
> **Q：列举 python2 和 python3 的区别**
>
> 
>
> **Q：什么是lambda函数？怎么用？**
>
> 
>
> **Q：别的编程语言都有三目运算符，三目运算符在python中怎么表达？**
>
> 
>
> **Q：try...except...else 和 try...except...finally 的区别是什么？**
>
> 
>
> **Q：什么是可迭代对象？可迭代对象的原理是什么？**
>
> 
>
> **Q：with...as 的原理是什么？**
>
> 
>
> **Q：解释一下python的GIL锁**
>
> 
>
> **Q：python 是单继承还是多继承？**
>
> 
>
> **Q：python 继承的顺序是什么？**
>
> 
>
> **Q：什么是元类？**
>
> 
>
> **Q：为什么都说 python 慢？**
>
> 



#### selenium

> **Q：selenium框架的运行原理**
>
> WebDriver（浏览器驱动）：
>
> - WebDriver 是 Selenium 的核心组件，它充当测试脚本和浏览器之间的桥梁。
> - 针对不同的浏览器（如 Chrome、Firefox、Edge 等），需要使用相应的 WebDriver 驱动程序。
> - WebDriver 驱动程序接收来自测试脚本的命令，并将其转换为浏览器可以理解的指令。
>
> 浏览器：
>
> - 浏览器接收到 WebDriver 驱动程序发送的指令后，执行相应的操作。
> - 例如，如果指令是“点击按钮”，浏览器就会模拟用户点击按钮的动作。
> - 浏览器执行操作后，将结果返回给 WebDriver 驱动程序。
>
> **Q：selenium定位元素的方法都有哪些**
>
> 绝对路径：从根节点到目标元素的完整路径 (`/html/body/div/span`)
>
> 相对路径：以双斜线开始的相对定位 (`//div[@id='login']`)
>
> 属性定位：通过元素属性定位 (`//input[@name='username']`)
>
> 文本定位：通过元素文本内容定位 (`//button[text()='登录']`)
>
> 包含文本：定位包含特定文本的元素 (`//div[contains(text(),'欢迎')]`)
>
> 包含属性：定位包含特定属性的元素 (`//input[contains(@class,'btn')]`)
>
> 索引定位：通过位置索引定位 (`//div[@class='item'][1]`)



#### Pytest

> 待施工
>
> 



#### Junit

> 待施工
>
> 



#### 测试文档

> Q：**测试用例都包含哪些要素？**
>
> 用例ID/编号：唯一标识符
>
> 用例名称：简洁描述测试目的
>
> 测试目标/描述：详细说明测试内容
>
> 前置条件：执行测试前必须满足的条件
>
> 测试数据：测试中使用的输入数据
>
> 测试步骤：详细的操作步骤
>
> 预期结果：测试后应该达到的状态
>
> 实际结果：测试执行后的实际状态
>
> 测试结果：通过/失败
>
> 优先级/严重程度：测试用例的重要性
>
> 备注：其他相关信息
>
> 创建/修改人和日期
>
> 
>
> Q：**测试报告需要展示哪些要素？**
>
> 摘要：概述测试范围、时间和总体结果
>
> 测试环境：硬件、软件配置和版本信息
>
> 测试范围：说明测试的功能和未测试部分
>
> 测试执行情况：计划vs实际的测试进度
>
> 测试结果统计：通过/失败/阻塞/未执行等数量
>
> 缺陷分布：按严重性、模块等分类的缺陷统计
>
> 主要问题：关键缺陷的详细说明
>
> 质量评估：产品质量判断和风险评估
>
> 建议：改进建议和未来测试计划
>
> 附录：支持文档和详细测试数据
>
> 
>
> Q：**测试排期应该怎么估算？**
>
> 分解任务：将测试工作拆分为小任务
>
> 评估复杂度：根据功能复杂度确定测试难度
>
> 考虑历史数据：参考类似项目的实际耗时
>
> 加入缓冲时间：预留20-30%应对风险和变更
>
> 考虑资源因素：测试人员数量和技能水平
>
> 考虑依赖关系：环境准备、开发交付等前置条件
>
> 评估测试类型：功能测试、自动化测试等不同类型
>
> 专家评审：邀请有经验的测试人员评审估算
>
> 迭代调整：根据实际进度定期调整计划
>
> 
>
> Q：**测试程序设计的不合理 与 测试程序完善但是测试人员出现失误，哪一项更严重？**
>
> 测试程序设计不合理更严重。
>
> 测试程序不合理是系统性问题，会长期影响测试质量和效率
>
> 设计不合理可能导致大范围的测试盲点，无法发现关键缺陷
>
> 人员失误通常是偶发性的，可以通过复查或其他测试人员交叉验证来弥补
>
> Q：**有一个触发概率极低但是非常致命的BUG，明天项目一定要上线，你怎么处理，不用非得解决，就是问我怎么处理这种事。**
>
> 风险评估：精确评估bug触发概率和可能造成的损失
>
> 监控方案：设置专门监控机制，实时检测bug触发条件
>
> 降级方案：准备出现问题时的应急响应和功能降级策略
>
> 损害控制：评估最坏情况并准备损害控制措施
>
> 预警系统：实现自动预警，一旦出现征兆立即报警
>
> 修复计划：安排紧急修复团队随时待命
>
> 透明沟通：向产品、管理层和客户坦诚风险，取得共识



#### Shell

> Q：什么场景下，适合编写 Shell 脚本来处理？
>
> 自动化系统管理任务
>
> - 批量文件操作（重命名、移动、备份）
> - 系统监控和日志处理
> - 定期清理临时文件或旧数据
> - 自动化系统备份
>
> 开发和构建流程
>
> - 代码编译和构建自动化
> - 开发环境配置
> - 持续集成/持续部署(CI/CD)流程
> - 依赖项安装和环境准备
>
> 数据处理
>
> - 日志文件分析和统计
> - 简单的文本处理和转换
> - CSV、JSON等结构化数据的基本处理
> - 数据提取和格式转换
>
> 网络和服务管理
>
> - 服务健康检查和重启
> - 网络连接测试和诊断
> - 简单的API调用和响应处理
> - 防火墙规则管理



#### TCP/UDP

> Q：**简单介绍 TCP 三次握手（为什么不是两次、四次）**
>
> 
>
> **Q：四次分手是什么？**
>
> 
>
> **Q：TCP 拥塞是什么？**
>
> 
>
> **Q：TCP怎么保证安全的，UDP能否也像TCP那样安全，怎么做？**
>
> 
>
> **Q：你知道 tcp 的控制可靠性的策略和重传机制么？**
>
> 
>
> **Q：TCP协议属于哪一层？**
>
> 



#### HTTP/HTTPS

> **Q：cookie 和 session 机制、区别**
>
> 
>
> **Q：输入url到网页显示出来中间的过程**
>
> 
>
> **Q：列举你知道的网页状态码**
>
> 
>
> **Q：3 开头的网络状态码的含义是什么？302和304的区别是什么？**
>
> 
>
> **Q：4 开头的网络状态码含义是什么？**
>
> 
>
> **Q：5 开头的网络状态码含义是什么？**
>
> 
>
> **Q：什么是 HTTPS？原理是什么？**
>
> 
>
> **Q：GET 和 POST 的区别是什么？**
>
> 
>
> **Q：网络请求 method 有哪几种？**
>
> 
>
> **Q：简单介绍一下什么是 RESTful API**
>
> 
>
> **Q：PUT 和 POST 的区别**
>
> 
>
> **Q：列举常见的请求 Header 头**
>
> 
>
> **Q：一个HTTP请求报文是什么样的？（GET举例）**
>
> 
>
> **Q：GET 的长度限制了解么？**
>
> 



#### 链表

> Q：一个有序链表，怎么求第K大个节点？
>
> 
>
> Q：怎么找出这两个链表是否有相交的点
>
> 
>
> Q：数组与链表的区别
>
> 
>
> Q：链表逆序
>
> 





#### 数组

> Q：怎么对俩有序数组合并？
>
> 
>
> Q：求数组中和为 n 的两个数，时间复杂度是多少？
>
> 
>
> Q：int 型数组，怎么排序？
>
> 
>
> Q：int 型数组，怎么去重？
>
> 



#### 复杂度

> Q：时间复杂度是什么？
>
> 
>
> Q：怎么计算时间复杂度？
>
> 



#### 排序

> Q：八大排序都有哪些？
>
> 
>
> Q：快排的原理
>
> 
>
> Q：归并排序的原理
>
> 
>
> Q：冒泡排序的原理
>
> 
>
> Q：插入排序的原理
>
> 
>
> Q：选择排序的原理
>
> 



#### 树

> Q：树的定义，代码实现
>
> 
>
> Q：什么是树的高度？怎么求？
>
> 
>
> Q：计算二叉树节点的个数
>
> 
>
> Q：什么是根结点？什么是叶子节点？
>
> 
>
> Q：打印二叉树
>
> 



#### 递归

> Q：什么是递归？
>
> 
>
> Q：递归的时间复杂度是什么？
>
> 



#### 堆与栈

> Q：堆和栈都有什么区别 
>
> 
>
> Q：代码实现栈
>
> 



#### 动态规划

> Q：什么是动态规划？
>
> 



#### 高级算法

> Q：什么是深度遍历？什么是广度遍历？
>
> 



#### 查找

> Q：能够实现二分查找的必要条件是什么？
>
> 







#### 其他

> Q：最大连接数和QPS区别
>
> 
>
> Q：网络一共分为几层？
>
> 
>
> Q：客户端向服务器请求图片和动态资源的区别
>
> 
>
> Q：图片渲染的过程 前端
>
> 
>
> Q：网络七层有哪些？tcp，udp，arp都在哪一层？
>
> 
>
> Q：QPS 和 TPS 的区别是什么？
>
> 
>
> Q：解释一下DNS
>
> 
>
> Q：什么是反向代理？
>
> 
>
> Q：什么是 socket？
>
> 



#### 编程题

> Q：求最大回文个数
>
> 
>
> Q：一个数组中有正数有负数（没有0），请将它排成正负相间的数组（多余的全部放后面），时间复杂度不超过O（n）
>
> 
>
> Q：一道编程题，输入一串由ABCD四个字随机组成的字符串和一个整数k，返回字符串种前k个字的顺序重复了几次。
>
> 
>
> Q：编程：判断一个字符串是否符合ipv4格式
>
> 
>
> Q：代码题，给一个句子，只把单词翻转然后输入
>
> 
>
> Q：【手撕代码】字符串中只出现一次的字符、找出数组中最小的四个数字
>
> 
>
> Q：代码：一串字符串中最小的整数
>
> 
>
> Q：写代码，类似高考成绩，一个表中有很多数据（无序的），给你一个成绩，查出在表中的排名
>
> 
>
> Q：编程题，鸡兔同笼，一半的兔子伸起一半的脚，输入地上有几只脚，列出所有的可能性（兔子是基数则整除2）
>
> 
>
> Q：判断一个字符串是否是点分十进制的ipv4格式
>
> 
>
> Q：100万个学生 按照成绩 及对应排名录入 分数查找排名（hashmap）
>
> 
>
> Q：python的编程题，输入一个字符串然后空格切割在统计每个字母出现的次数
>
> 



#### HR常问

> Q：为什么想做测试
>
> 
>
> Q：对测开的理解
>
> 
>
> Q：测试过程中有没有出现问题，是如何解决的
>
> 
>
> Q：最近看了什么书？学了什么？为什么学？有看什么技术书籍吗？
>
> 
>
> Q：个人优缺点，举例
>
> 
>
> Q：测试看重什么能力
>
> 
>
> Q：项目问题细挖
>
> 
>
> Q：为什么选择xx公司？
>
> 
>
> Q：你对我们公司有什么了解吗？
>
> 
>
> Q：之前实习收获了什么
>
> 
>
> Q：介绍下自己的优缺点
>
> 
>
> Q：抗压能力如何，描述一件自己如何抗压的经历
>
> 
>
> Q：反问环节：你有什么问题想问我么？
>
> 
>
> Q：项目中收获了什么？
>
> 
>
> Q：平时怎么学习的
>
> 
>
> Q：为什么要离职？
>
> 
>
> Q：你的期望薪资是多少？
>
> 

