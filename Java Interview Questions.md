# 参考资料
[Java面试题](https://javabetter.cn/sidebar/sanfene/collection.html#_1-说说有哪些常见的集合框架)
# 一、Java基础
## java中的基本数据类型
| 数据类型    | 初始值     |
| ------- | ------- |
| byte    | 0       |
| short   | 0       |
| int     | 0       |
| long    | 0L      |
| float   | 'u0000' |
| double  | 0.0f    |
| char    | 0       |
| boolean | false   |
| 所有引用类型  | null    |

## 面向对象的三个基本特征
- **继承**：继承是从已有类得到继承信息创建新类的过程。例如子类继承父类，
- **封装**：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。例如常说的把这段方法封装一下
- **多态性**：多态性是指允许不同子类型的对象对同一消息作出不同的响应。**实现多态，就有覆盖、重载两种方法**。

## 创建对象的几种方式
1. 使用 new 关键字：使用 new 关键字可以在堆内存中创建一个新的对象。
2. 通过反射机制：通过Java反射机制，可以在运行时动态地获取类的信息并创建对象。这种方式可以通过 Class 类的 newInstance() 方法或 Constructor 类的 newInstance() 方法来创建对象。
3. 通过 clone() 方法：Cloneable接口提供了 clone() 方法，通过该方法可以创建一个对象副本。被复制的对象必须实现 Cloneable 接口。
4. 通过反序列化：将一个对象序列化成字节流后，可以通过反序列化操作将其重新转换为对象。这种方式可以使用 ObjectInputStream 类的 readObject() 方法来实现。
5. 使用工厂模式：通过定义一个工厂类，使用该工厂类中的静态方法来创建对象。这样可以封装对象的创建过程，并且可以根据需要返回不同类型的对象。
6. 使用单例模式：通过单例模式可以确保一个类只有一个实例对象，可以使用静态方法或者静态块来创建这个唯一的实例。
7. 通过依赖注入框架：使用依赖注入框架（如Spring）可以自动创建对象并注入依赖。

## float f=3.4;是否正确
​不正确。3.4是双精度数，需要强制类型转换float f =(float)3.4,或者写成float f =3.4F。

## 原始类型和包装类型
- 原始类型：boolean, char, byte, short, int, long, float, double
- 包装类型：Boolean, Character, Byte, Short, Integer, Long, Float, Double

## &和&&的区别
- 当&运算符两边的表达式的结果都为true时，整个运算结果才为true。
- &&运算符第一个表达式为false时，则结果为false，不再计算第二个表达式。
- &还可以用作位运算符，当&操作符两边的表达式不是boolean类型时，&表示按位与操作

## 数组有没有length()方法？String有没有length()方法
数组没有length()方法，有length 的属性。String 有length()方法

## 重载和重写的区别
重写(Override)：是子类对父类允许方位的方法的实现过程进行重新编写，返回值和形参都不能改变。即外壳不变，核心重写。
重载(Overload)：是在一个类里面，方法名字相同，二参数不同。返回类型可以相同也可以不同，每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

| 区别点  | 重载方法 | 重写方法                   |
| ---- | ---- | ---------------------- |
| 参数列表 | 必须修改 | 一定不能修改                 |
| 返回类型 | 可以修改 | 一定不能修改                 |
| 异常   | 可以修改 | 可以减少或删除，一定不能抛出新的或更广的异常 |
| 访问   | 可以修改 | 一定不能做更严格的限制（可以降低限制）    |

## String、StringBuffer和StringBuilder之间的区别
String长度不可变，StringBuffer和StringBuilder都是长度可变的。
​StringBuilder的效率要比StringBuffer高。但是String的效率是最低的

## 构造器（constructor）是否可被重写（override）
构造器不能被继承，因此不能被重写，但可以被重载

## 抽象类（abstract class）和接口（interface）有什么异同
- 实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。
- 构造函数：抽象类可以有构造函数；接口不能有。
- main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。
- 实现数量：类可以实现很多个接口；但是只能继承一个抽象类。
- 访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。 

## 作用域public, private, protected以及不写时的区别
不能用protected和和private修饰类

| 作用域           | 当前类 | 同一package | 子孙类 | 其他package |
| ---------------- | ------ | ----------- | ------ | ----------- |
| public           | √      | √           | √      | √           |
| protected        | √      | √           | √      |             |
| 不写（friendly） | √      | √           |        |             |
| private          | √      |             |        |             |

## 常见的异常类有哪些？
- NullPointerException 空指针异常
- ClassNotFoundException 指定类不存在
- NumberFormatException 字符串转换为数字异常
- IndexOutOfBoundsException 数组下标越界异常
- ClassCastException 数据类型转换异常
- FileNotFoundException 文件未找到异常
- NoSuchMethodException 方法不存在异常
- IOException IO 异常
- SocketException Socket 异常

## HashMap和Hashtable的区别
- HashMap允许空（null）键值（key），HashMap允许将null作为一个entry的key或者value，而Hashtable不允许
- 由于非线程安全，HashMap效率上可能高于Hashtable。
- Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。 

## Java中有哪些数据结构，并且它们是怎么实现的
1. ArrayList
	- 实现原理：基于动态数组
	- 核心特点：
	    - 底层使用 Object[] 数组存储元素
	    - 当容量不足时，创建更大的新数组（通常为当前容量的 1.5 倍）并复制元素
	    - 随机访问 O(1)，插入/删除需要移动元素 O(n)
	    - 非线程安全
2. LinkedList
	- 实现原理：双向链表
	- 核心特点：
	    - 每个节点包含前驱引用、后继引用和元素值
	    - 实现了 List 和 Deque 接口
	    - 插入/删除操作 O(1)（如果已知位置），查找 O(n)
	    - 非线程安全
3. HashMap
	- 实现原理：哈希表 + 链表/红黑树
	- 核心特点：
	    - Java 8 前：数组 + 链表
	    - Java 8 后：数组 + 链表 + 红黑树（链表长度 > 8 且数组长度 > 64 时转为红黑树）
	    - 负载因子默认 0.75
	    - 非线程安全，存取 O(1) 平均时间复杂度
	    - 允许 null 键和值
4. TreeMap
	- 实现原理：红黑树
	- 核心特点：
	    - 基于红黑树的 NavigableMap 实现
	    - 键按自然顺序或指定比较器排序
	    - 查找、添加、删除操作都是 O(log n)
	    - 不允许 null 键
5. Hashtable
	- 实现原理：哈希表
	- 核心特点：
	    - 线程安全（同步方法）
	    - 不允许 null 键或值
	    - 性能低于 HashMap，现代代码很少使用
6. HashSet
	- 实现原理：基于 HashMap
	- 核心特点：
	    - 内部使用 HashMap 实例，值是固定的 PRESENT 对象
	    - 不保证迭代顺序
	    - 允许 null 元素

## 排序都有哪几种方法？请列举
- 插入排序（直接插入排序、希尔排序）
- 交换排序（冒泡排序、快速排序）
- 选择排序（直接选择排序、堆排序）

## 什么是事务
事务(Transaction)是并发控制的基本单位。所谓事务,它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。

## 事务的特性
- 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行
- 一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。
- 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行
- 持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中


# 二、Java框架

# 三、线程相关
## 创建线程有哪几种方式
​继承Thread类创建线程类
​通过Runnable接口创建线程类
​通过Callable和Future创建线程 

## 线程有哪些状态？
​线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。

# 四、JVM相关
### 描述一下JVM加载class文件的原理机制?
JVM中类的装载是由 ClassLoader 和它的子类来实现的, Java ClassLoader 是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。


# 五、中间件相关
## 什么是缓存
缓存是一种临时存储数据的技术，目的是为了提高数据访问速度和系统性能。在软件开发中，缓存通常用于存储频繁访问的数据副本，以便将来能够更快地获取这些数据而不必每次都从原始数据源中获取。缓存可以存在于各种形式，包括内存、硬盘、数据库等。
**答**：在Java开发中，缓存通常通过使用缓存库或者框架来实现，比如常用的Redis。将经常使用的数据存储在内存中，程序可以减少对数据库或其他外部数据源的频繁访问，从而提高系统的性能和响应速度。

## 为什么需要缓存
缓存的存在有几个重要的原因：
1. **提高性能**：缓存能够存储频繁访问的数据，减少了从数据库或其他数据源获取数据的次数。由于内存访问速度通常比硬盘或网络访问速度更快，因此通过缓存可以大大提高数据访问的速度，提升应用程序的性能。
2. **降低系统负载**：频繁的数据库或其他外部数据源访问会增加系统的负载，尤其是在高并发环境下。通过使用缓存，可以减轻数据源的压力，降低系统负载，提高系统的可伸缩性和稳定性。
3. **减少网络延迟**：如果数据存储在远程服务器上，每次访问都需要经过网络传输，会导致较高的延迟。通过使用缓存，在应用程序本地存储数据副本，可以减少网络传输的次数，从而降低访问数据的延迟。
4. **提高数据可用性**：缓存可以在某些情况下提高数据的可用性。例如，如果数据库发生故障或者网络连接中断，应用程序仍然可以从缓存中获取数据，确保系统的正常运行。
5. **降低成本**：通过减少对数据库或其他外部数据源的频繁访问，可以降低系统的运行成本，尤其是在云计算环境下，减少数据传输和存储的成本。