#### HR常问

> Q：**自我介绍**
>
> 面试官，你好！我叫黄昱桥，2021年毕业于湖北工业大学工程技术学院计算机科学与技术专业。我拥有3年的软件开发与测试经验，上一家公司是在亚信科技担任软件测试工程师，负责项目的软件测试、开发工作。
> 在上一家公司，我的主要职责包括：担任测试小组组长，负责制定测试计划，分解测试任务，安排功能上线，设计并执行自动化测试脚本，编写详尽的测试报告，确保项目测试覆盖率和有效性。其中在中国移动收钱宝项目中我开发了Python自动化测试工具，将测试效率提升30%。
> 我掌握自动化和常用测试技术，熟悉Postman、Jmeter等测试工具，熟练掌握Java、Python、Vue，React等开发技术，掌握SQL语言和数据库知识，掌握Linux、Docker，有测试、开发环境搭建能力，熟练使用Git进行版本控制。 并且我持有PMP认证，能够高效协调团队资源。
>
> 
>
> Q：**反问环节：你有什么问题想问我么？**
>
> 1.我很想了解的是关于这个岗位的具体工作内容
>
> 2.做的项目大概是做哪方面的、未来主要是做哪些模块
>
> 
>
> Q：**是否离职，为什么要离职？**
>
> 已经离职了，上家公司的职位的发展空间有限，没法获得新的技能和晋升机会。再加上武汉这座城市的IT行业的发展不是特别好，所以选择离职。
>
> 
>
> Q：**你目前薪资是多少，你的期望薪资是多少？**
>
> 目前在武汉是8*13K，期望是13~14K
>
> 
>
> Q：**知不知道是外派/驻点的岗位**
>
> 知道的，有跟我说过
>
> 
>
> Q：**你能不能接受加班（未必是真的加班多，但还是考察个人对工作的热爱程度）**
>
> 能接受，我之前公司也是有时候会有很多加班
>
> 
>
> Q：**你的到岗时间是多久**
>
> 我的最快到岗时间是三周
>
> 
>
> Q：**职业规划、喜欢的工作氛围等。**
>
> 我的长期的职业规划是在入职新公司以后，尽快的熟悉并且掌握工作，然后根据我掌握的PMP项目管理的知识慢慢的去带一些团队，把我脑子里的只是转换成实践，最后走向项目管理的岗位上去。
>
> 我喜欢学习型+宽松的并且积极向上的工作氛围。



#### 工作内容

> **Q：按测试内容划分，测试有哪些种类？**
>
> 功能测试、性能测试、安全测试、兼容性测试、界面测试、易用性测试、可靠性测试、配置测试、数据库测试、接口测试、本地化测试、恢复测试、文档测试和安装测试等。
>
> 
>
> **Q：软件开发（测试）的流程是怎么样的？**
>
> 软件开发测试流程：需求分析 → 测试计划 → 测试设计 → 测试环境搭建 → 测试执行 → 缺陷跟踪与管理 → 测试报告 → 回归测试 → 验收测试。
>
> 
>
> **Q：你印象最深刻的 bug 是？**
>
> 在中国移动收钱宝项目中，我们曾遇到遇到一些用户反馈查不到订单的问题。这就是丢单了，顺便去我就去定位了一下这些订单是怎么丢的，然后根据用户说的支付时间，去查日志，什么也没查到，想了想我就去数据库查了一下，发现订单是在数据库里的，再排查才知道是是往es写入的时候出错了，由于前台是查的es，所以没订单，最后在投产日通过手动补单的方式先补上了订单。再在下一个迭代周期上线了通过xxljob定时任务去扫描数据库和es的方式去彻底解决了这个问题。
>
> 
>
> Q：**项目快上线但是因为开发而延迟，测试时间被压缩怎么办**
>
> 首先看自己还剩多少时间，然后评估一下工作量，评估一下风险，记录一下转测的时间（能够测试的时间）比原先延期了几天，上报风险给相关负责人。
>
> 然后，如果说我可能根本做不完，这个风险太大，那我就得把这个风险提出来给相关负责人，请求协助，然后评估一下需要多少人力
>
> 如果说，正常时间完不成的话，那我会提一下加班，然后看加班能否完成。
>
> 其他的，我就会首先跟领导确认，比如说我只需要把优先级高的工作做完，其他的安排到下一个版本。这样的话，那我就会列一个计划，然后把计划上报给领导
>
> 
>
> Q：**给你一个需求，你具体说一下，你怎么测试**
>
> 1. 首先熟悉这个需求的背景，需要的功能，我至少要知道这个需求是做什么的。
> 2. 然后我会看这个需求和其他什么模块有没有关联，会不会影响其他模块，或者数据有没有流向其他模块
> 3. 之后我会去评估工作量和需要的人力，看哪个时间点交付，需要多少人力，然后做一个计划去给领导看看。
> 4. 最后就是去做需求分析、测试用例编写，尽量都去做评审，保证好质量，没有问题的话就是去执行测试，跟踪bug，之后就去出一个测试报告。
>
> 
>
> Q：**返回的数据有问题，怎么排查问题**
>
> 1. 首先就是去抓包了，看看前台和后台交互的情况，确认一下是不是前台请求发送时候有问题而导致的返回数据有问题。
> 2. 如果没有问题的话，就去看接口文档，看返回的数据具体是哪里出了问题，然后排查数据库，是不是数据库的数据有问题。
> 3. 然后再都没有问题的话，那就是代码的问题了，我就回去查后台的日志，分析日志文件的错误信息排查具体问题原因。





#### 测试方法

> Q：**黑盒测试的方法有哪些？**
>
> 等价类划分：将输入数据分为有效等价类和无效等价类
>
> 边界值分析：测试边界条件（如最小/最大值，临界值）
>
> 错误推测：根据经验预测可能出现错误的地方
>
> 因果图：分析输入条件与输出结果的关系
>
> 决策表测试：处理不同条件组合的测试方法
>
> 场景测试：模拟用户使用场景
>
> 正交数组测试：减少测试用例数量但保持覆盖率
>
> 状态转换测试：测试系统在不同状态间的转换
>
> 
>
> Q：**白盒测试的方法有哪些？**
>
> 语句覆盖：确保每个语句至少执行一次
>
> 判定覆盖（分支覆盖）：确保每个决策的每个可能结果至少执行一次
>
> 条件覆盖：确保每个条件的每个可能结果至少执行一次
>
> 判定/条件覆盖：结合判定覆盖和条件覆盖
>
> 条件组合覆盖：测试所有条件的组合
>
> 路径覆盖：确保程序中所有可能的路径都被测试
>
> 基本路径测试：基于代码的循环复杂度设计测试用例
>
> 数据流测试：追踪变量的定义和使用
>
> 
>
> Q：**什么是单元测试？**
>
> 单元测试是对软件中最小可测试单元（通常是函数、方法或类）进行验证的测试方法。它由开发人员编写，目的是确保代码功能正确。单元测试通常使用框架（如JUnit、PyTest）自动化执行，并且应该是隔离的、快速的、可重复的。好的单元测试能提早发现问题，便于重构，并作为代码的文档。
>
> 
>
> Q：**什么是集成测试？**
>
> 集成测试是在单元测试之后进行的，测试多个已经过单元测试的模块组合在一起是否能正确工作。目的是发现接口缺陷或模块之间交互的问题。集成测试可采用自顶向下、自底向上或混合的策略，一般需要更复杂的测试环境和数据，测试范围更广，执行更慢。
>
> 
>
> Q：**测试用例怎么编写与设计？**
>
> 分析需求文档，理解功能和业务规则
>
> 确定测试边界和范围
>
> 使用黑盒测试方法（等价类划分、边界值分析等）
>
> 考虑正向测试（验证正常功能）和反向测试（验证异常处理）
>
> 设计测试数据，包括有效和无效数据
>
> 明确测试前提、步骤和预期结果
>
> 评审并优化测试用例，确保测试覆盖率
>
> 设置优先级，重要功能优先测试
>
> 
>
> Q：**什么是灰盒测试？**
>
> 灰盒测试介于黑盒和白盒测试之间，测试人员了解部分内部结构，但不需完全了解源代码。
>
> 结合了黑盒和白盒测试的优点
>
> 基于有限的结构信息设计测试用例
>
> 可以针对特定的内部路径设计测试
>
> 适合测试数据库、安全性、面向对象等场景
>
> 能更高效地发现基于数据流和内部边界的问题
>
> 
>
> Q：**黑盒测试和白盒测试的区别**
>
> 定义：
>
> - 黑盒测试：测试者不了解系统内部结构和代码，仅关注输入和输出，验证功能是否符合需求。
> - 白盒测试：测试者了解系统内部结构和代码，基于代码逻辑设计测试用例，检查程序的执行路径和内部行为。
>
> 测试视角：
>
> - 黑盒测试：从用户角度出发，模拟用户操作，关注系统外部行为。
> - 白盒测试：从开发者角度出发，深入代码层面，关注程序的实现细节。
>
> 知识要求：
>
> - 黑盒测试：不需要编程知识，只需了解需求规格说明书和功能描述。
> - 白盒测试：需要了解代码结构、编程语言和开发工具。
>
> 测试方法：
>
> - 黑盒测试：常见技术包括等价类划分、边界值分析、决策表、用例设计等。
> - 白盒测试：常见技术包括代码覆盖率分析（如语句覆盖、分支覆盖、路径覆盖）、控制流测试等。
>
> 目标：
>
> - 黑盒测试：验证系统功能是否满足用户需求，检查是否按预期工作。
> - 白盒测试：发现代码中的逻辑错误、潜在漏洞，确保程序的健壮性和正确性。
>
> 适用场景：
>
> - 黑盒测试：适合功能测试、验收测试、系统测试，常用于用户界面或API测试。
> - 白盒测试：适合单元测试、集成测试，常用于开发阶段优化代码质量。
>
> 优缺点：
>
> - 黑盒测试
>   - 优点：独立于代码实现，测试视角贴近用户体验；易于设计测试用例。
>   - 缺点：无法发现代码内部隐藏的问题，覆盖率可能不足。
> - 白盒测试
>   - 优点：能发现代码逻辑错误，提高代码覆盖率。
>   - 缺点：测试成本高，依赖代码知识，修改代码可能导致测试用例失效。



#### 接口测试

> Q：**在手工接口测试或者自动化接口测试的过程中，上下游接口有数据依赖如何处理？**
>
> 自动化测试需要通过脚本实现数据依赖的动态处理，常用方法包括：
>
> - 动态提取和传递数据
>   - 步骤
>     1. 调用上游接口，解析响应数据（如JSON/XML），提取关键字段（使用JSONPath、XPath或正则表达式）。
>     2. 将提取的数据存储为变量或上下文参数。
>     3. 在下游接口的请求中动态引用这些变量。
>   - 工具支持
>     - **Postman**：使用脚本（如JavaScript）在“Tests”标签中提取响应数据，保存到环境变量（如pm.environment.set("orderId", pm.response.json().id)），后续请求引用变量（如{{orderId}}）。
>     - **Python Requests**：解析响应（如response.json()['id']），保存到全局变量或配置文件。
>   - **优点**：自动化程度高，适合复杂依赖场景。
> - 测试数据初始化
>   - 在测试脚本运行前，通过前置步骤调用上游接口或直接操作数据库，生成所需的测试数据。
>   - 例如，测试套件开始时调用“创建用户”接口，保存返回的用户ID供后续接口使用。
>   - 实现方式
>     - 使用测试框架的@Before或setUp方法（如JUnit、Pytest）。
>     - 编写独立的数据准备脚本，生成批量测试数据。
>   - **注意**：确保数据隔离（如使用随机化数据或独立测试环境），避免测试用例相互干扰。
> - Mock服务
>   - 使用自动化工具（如WireMock、MockServer、Mountebank）模拟上游接口，预定义返回数据。
>   - 测试脚本直接调用Mock接口获取数据，传递给下游接口。
>   - **适用场景**：上游接口不稳定、开发未完成或需要特定场景数据。
>   - 实现方式
>     - 配置Mock规则，定义响应模板。
>     - 在自动化脚本中调用Mock服务的URL代替真实上游接口。
> - 数据库操作
>   - 通过脚本直接访问数据库，获取或插入测试数据。
>   - 例如，使用Python的pymysql或Java的JDBC查询上游接口需要的ID，传递给下游接口。
>   - 注意
>     - 确保数据库操作事务一致，避免数据污染。
>     - 使用独立的测试数据库，防止影响生产环境。
> - 参数化配置文件
>   - 将依赖数据存储在配置文件（如JSON、YAML）或环境变量中，测试脚本动态读取。
>   - 例如，预先运行脚本生成依赖数据，保存到config.json，下游接口从文件中读取参数。
>   - **优点**：便于维护，适合固定场景的测试。
>
> **在 JMeter 中处理数据依赖**
>
> JMeter 是一个功能强大的接口测试工具，支持多种方式处理上下游接口的数据依赖。以下是具体实现步骤：
>
> 1. **提取上游接口的响应数据**
>
> - JSON Extractor
>
>   （推荐用于 JSON 响应）：
>
>   - 在上游接口的 HTTP 请求下添加后置处理器（Post-Processor） -> 选择“JSON Extractor”。
>   - 配置：
>     - Name of created variable：定义变量名（如 userId）。
>     - JSON Path expressions：填写 JSONPath 表达式（如 $.data.userId）。
>     - Match No.：填写匹配序号（通常为 1，若有多条数据可指定）。
>   - 示例：若上游接口返回 {"data": {"userId": "12345"}}，JSONPath 为 $.data.userId，提取后变量 userId 值为 12345。
>
> - Regular Expression Extractor
>
>   （适用于非 JSON 格式）：
>
>   - 添加“Regular Expression Extractor”作为后置处理器。
>   - 配置正则表达式提取目标字段。
>   - 示例：若响应为 <userId>12345</userId>，正则表达式为 <userId>(.*?)</userId>，提取变量名为 userId。
>
> - XPath Extractor
>
>   （适用于 XML 响应）：
>
>   - 用于 XML 格式的响应数据提取。
>
> 2. **存储提取的数据**
>
> - JMeter 会自动将提取的数据存储为变量，变量名即为配置的 Name of created variable。
> - 变量可直接在后续请求中使用，无需额外存储。
>
> 3. **传递数据到下游接口**
>
> - 在下游接口的 HTTP 请求中，使用 ${变量名} 引用提取的变量。
> - 示例：
>   - 请求体：{"userId": "${userId}"}
>   - 请求头：Authorization: Bearer ${token}
>   - URL 参数：http://example.com/api?userId=${userId}
> - 确保变量名一致，且上游接口已成功执行。
>
> 4. **确保接口调用顺序**
>
> - JMeter 的测试计划（Test Plan）中，HTTP 请求是按线程组（Thread Group）顺序执行的。
> - 将上游接口和下游接口放在同一个线程组内，按顺序排列。
> - 如果需要复杂逻辑（如条件跳转），可以使用：
>   - Logic Controller（如 If Controller、Loop Controller）。
>   - Transaction Controller：将相关接口分组，确保执行顺序。
>
> 5. **异常处理**
>
> - 使用 
>
>   Response Assertion
>
>    检查上游接口是否返回预期结果。
>
>   - 示例：检查响应中是否包含 200 状态码或特定字段。
>
> - 如果上游接口失败，可以通过 
>
>   If Controller
>
>    跳过下游接口。
>
>   - 示例：${__jexl3("${userId}" != "<NONE>")} 表示仅在 userId 非空时执行下游请求。
>
> - 使用 **Test Action** 暂停或停止测试。
>
> 
>
> Q：**依赖于第三方数据的接口如何进行测试？**
>
> 方法一：Mock 第三方服务
>
> - 适用场景：第三方服务不稳定、访问受限（如限频、收费），或需要模拟特定响应。
> - 实现方式
>   - 本地 Mock 服务器
>     - 使用工具如 WireMock、MockServer 或 Postman Mock Server 搭建本地模拟服务。
>     - 定义第三方接口的模拟响应（如 JSON 数据、状态码、延迟）。
>     - 将测试环境的接口地址指向 Mock 服务器。
>   - 框架支持
>     - 自动化测试框架（如 Python 的 unittest + responses 库、Java 的 Mockito）可以模拟第三方接口。
> - 优点：完全可控，测试数据稳定，适合开发初期或第三方不可用时。
> - 缺点：需要维护 Mock 数据，可能无法覆盖真实场景。
>
> 方法二：使用真实第三方服务（沙箱环境）
>
> 适用场景：第三方提供测试环境（沙箱），数据接近真实生产环境。
>
> 实现方式：
>
> - 获取第三方提供的沙箱环境地址、测试账号或 API Key。
> - 配置测试脚本调用沙箱环境的接口。
> - 定期检查沙箱环境的数据更新，确保测试数据有效。
>
> 优点：接近真实环境，测试结果更可靠。
>
> 缺点：依赖第三方沙箱的稳定性，可能需要额外配置或费用。
>
> 
>
> Q：**当一个接口出现异常时候，你是如何分析异常的？**
>
> 1. **确认异常信息**：查看日志或错误提示，获取异常的具体信息，如错误码、错误消息、堆栈跟踪等。例如，HTTP 状态码（500、404等）或自定义异常描述。
> 2. **重现问题**：尝试复现异常，记录请求的输入参数、URL、方法（GET/POST等）以及环境（开发/生产）。这有助于确定是偶发还是稳定复现。
> 3. 检查请求和响应
>    - **请求**：验证请求参数格式、内容是否正确，是否有缺失或非法值。
>    - **响应**：分析返回的错误信息，判断是客户端问题（如参数错误）还是服务端问题（如逻辑异常、依赖服务故障）。
> 4. 日志分析
>    - 查看接口服务端日志，定位异常发生的代码位置。
>    - 检查相关时间点的系统日志，寻找是否有资源瓶颈（如CPU、内存）或外部依赖（如数据库、第三方API）异常。
> 5. 依赖排查
>    - 如果接口依赖数据库，检查SQL语句是否正确、索引是否命中、连接池是否正常。
>    - 如果涉及第三方服务，确认对方服务状态、响应时间或限流情况。
> 6. 代码审查
>    - 定位到异常抛出的代码段，检查是否存在逻辑错误、边界条件未处理或空指针等问题。
>    - 确认是否有近期代码变更可能引入问题。
> 7. 环境对比
>    - 如果异常只在特定环境（如生产）出现，比较开发、测试、生产环境的配置差异（如版本、参数、负载）。
> 8. 假设验证
>    - 根据以上信息，列出可能的异常原因（如参数校验失败、数据库超时、网络中断）。
>    - 通过调整参数、模拟场景或临时修复逐一验证假设。
> 9. 总结与优化
>    - 确定根因后，修复问题并记录。
>    - 优化代码或配置，添加必要的监控、降级机制或异常处理，防止类似问题再次发生。
>
> 
>
> Q：测试的数据你放在哪？
>
> 1. 配置文件，json，yaml，properties
>
>    **优点**：
>
>    - 易于维护，修改数据无需改代码。
>    - 支持动态加载，适合不同环境切换。
>
>    **缺点**：
>
>    - 数据量大时，文件管理复杂。
>    - 不适合动态生成或复杂逻辑的数据。
>
> 2. 测试代码中
>
>    **优点**：
>
>    - 实现简单，适合快速开发。
>
>    **缺点**：
>
>    - 数据与代码耦合，修改麻烦。
>    - 不利于数据复用和维护。
>
> 3. 数据库
>
>    **优点**：
>
>    - 支持大量数据管理和复杂查询。
>    - 可模拟生产环境数据。
>
>    **缺点**：
>
>    - 维护成本高，需额外管理数据库。
>    - 数据初始化和清理复杂。
>
> 4. Excel/Csv文件
>
>    **优点**：
>
>    - 便于非开发人员编辑。
>    - 数据可视化，直观易懂。
>
>    **缺点**：
>
>    - 解析文件增加代码复杂度。
>    - 不适合动态数据或复杂结构。
>
> 5. Mock数据
>
>    **优点**：
>
>    - 灵活性高，减少静态数据维护。
>    - 适合边界测试或压力测试。
>
>    **缺点**：
>
>    - 实现和配置成本较高。
>    - 数据一致性可能需要额外控制。
>
> 
>
> **Q：对一个接口编写测试用例**
>
> **1. 功能性测试：**
>
> - 正常场景：
>   - 使用正确的参数，验证接口是否返回预期的结果。
>   - 验证接口返回的数据结构是否正确。
>   - 验证接口返回的数据类型是否正确。
> - 异常场景：
>   - 使用错误的参数类型，验证接口是否返回错误提示。
>   - 使用缺失的必填参数，验证接口是否返回错误提示。
>   - 使用超出范围的参数值，验证接口是否返回错误提示。
>   - 使用无效的参数值，验证接口是否返回错误提示。
>   - 测试错误的token验证，查看返回的错误信息。
> - 边界值测试：
>   - 测试参数的边界值，验证接口是否正确处理。
>   - 测试超长字符的参数，验证接口是否正确处理。
> - 业务逻辑测试：
>   - 验证接口是否按照业务规则正确处理数据。
>   - 验证接口是否正确处理各种业务场景。
> - 数据一致性：
>   - 测试接口操作后，数据库的数据是否一致。
>
> **2. 性能测试：**
>
> - 响应时间：
>   - 测试接口在正常负载下的响应时间。
>   - 测试接口在高负载下的响应时间。
> - 并发测试：
>   - 测试接口在高并发情况下的性能。
> - 压力测试：
>   - 测试接口在极限负载下的性能。
>
> **3. 安全性测试：**
>
> - 身份验证：
>   - 验证接口是否需要身份验证。
>   - 验证接口是否使用安全的身份验证机制。
> - 权限控制：
>   - 验证接口是否正确控制用户权限。
>   - 验证未授权用户是否无法访问接口。
> - 数据加密：
>   - 验证接口是否对敏感数据进行加密。
>   - 测试SQL注入，XSS攻击等。
> - 参数校验：
>   - 测试接口对于参数的校验，是否对于异常参数都做了过滤。
>
> **5. 异常测试：**
>
> - 网络异常：
>   - 测试接口在网络异常情况下的表现。
> - 服务器异常：
>   - 测试接口在服务器异常情况下的表现。
> - 数据库异常：
>   - 测试数据库异常情况下，接口的表现。
>
> 
>
> Q：**接口测试执行中比对数据库吗？**
>
> 肯定啊，因为接口返回值的数据来源于数据库，接口对数据的操作还要进行深层次的数据库检查！
>
> 
>
> Q：**Http状态码**
>
> - 1XX：请求已经接受，继续处理
> - 2XX：成功
> - 3XX：重定向
> - 4XX：客户端错误
> - 5XX：服务器错误
>
> 
>
> Q：**常见的post请求，提交数据格式有哪几个？**
>
> 在Web开发中，POST请求是一种常用的HTTP方法，用于向服务器提交数据。以下是几种常见的POST请求数据提交格式：
>
> 1. **x-www-form-urlencoded**：
>    这是表单提交的默认格式。数据被编码为键值对，并通过URL查询字符串的方式发送。例如：
>    ```
>    POST /submit HTTP/1.1
>    Host: www.example.com
>    Content-Type: application/x-www-form-urlencoded
>    user_id=123&password=abc
>    ```
>
> 2. **multipart/form-data**：
>    当需要上传文件时使用这种格式。它允许文件和文本字段一起发送，并且可以处理非ASCII字符。数据被分为多个部分，每个部分都有自己的内容类型和长度。例如：
>    ```
>    POST /submit HTTP/1.1
>    Host: www.example.com
>    Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryXXXXX
>    ------WebKitFormBoundaryXXXXX
>    Content-Disposition: form-data; name="user_id"
>    123
>    ------WebKitFormBoundaryXXXXX
>    Content-Disposition: form-data; name="file"; filename="file.txt"
>    Content-Type: text/plain
>    [文件内容]
>    ------WebKitFormBoundaryXXXXX--
>    ```
>
> 3. **application/json**：
>    这种格式用于发送JSON格式的数据。它通常用于API调用，其中客户端和服务器之间交换结构化数据。例如：
>    ```
>    POST /api/submit HTTP/1.1
>    Host: www.example.com
>    Content-Type: application/json
>    {
>      "user_id": 123,
>      "password": "abc"
>    }
>    ```
>
> 4. **application/xml**：
>    类似于JSON，这种格式用于发送XML格式的数据。虽然不如JSON流行，但在某些特定场景下仍然有用。例如：
>    ```
>    POST /submit HTTP/1.1
>    Host: www.example.com
>    Content-Type: application/xml
>    <?xml version="1.0" encoding="UTF-8"?>
>    <root>
>      <user_id>123</user_id>
>      <password>abc</password>
>    </root>
>    ```
>
> 5. **text/plain**：
>    这种格式用于发送纯文本数据。它不常用于表单提交，但在某些情况下可能用于发送简单的文本信息。例如：
>    ```
>    POST /submit HTTP/1.1
>    Host: www.example.com
>    Content-Type: text/plain
>    user_id=123&password=abc
>    ```
>
> 
>
> Q：**接口自动化框架如何搭建？**
>
> 搭建接口测试自动化框架是一个系统化的过程，涉及到需求分析、技术选型、框架设计、测试用例编写、测试执行和结果分析等多个环节。
>
>
> 以下是一个基于Python语言的接口测试自动化框架搭建的基本步骤和思路：
>
> 1. 需求分析与规划
>
> 确定测试目标，了解需要测试的接口特性，包括但不限于功能、性能、安全性等。
>
> 2. 技术选型
>
> 选择合适的编程语言和工具，Python因其简洁和强大的库支持而广泛用于自动化测试。常用的库包括`requests`用于发送HTTP请求，`pytest`或`unittest`用于编写和执行测试用例。
>
> 3. 框架设计
>
> 设计测试框架的结构，通常包括以下几个部分：
> - 基础环境：如Python版本、编译器（如PyCharm）、虚拟环境管理等。
> - 配置管理：使用如`configparser`的库来管理测试环境配置。
> - 数据管理：使用Excel、YAML、JSON等格式来存储测试数据。
> - 测试用例：编写测试用例，可以使用`pytest`结合`allure`生成测试报告。
> - 日志管理：使用`logging`模块来记录测试过程中的日志信息。
> - 报告生成：使用`allure`或其他工具生成详细的测试报告。
>
> 4. 测试用例编写
>
> 根据测试需求编写测试用例，可以使用`pytest`的参数化测试来实现数据驱动测试。
>
> 5. 持续集成
>
> 将测试框架集成到CI/CD流程中，使用如Jenkins等工具自动执行测试。
>
> 6. 测试执行
>
> 执行测试用例，可以是本地运行或集成到CI/CD流程中。
>
> 7. 结果分析
>
> 分析测试报告，确定测试结果是否符合预期，并对失败的测试用例进行调试。
>
> 8. 维护与优化
>
> 根据测试结果和项目需求对测试框架进行维护和优化。
>
> 
>
> Q：**没有接口文档时如何进行接口测试？**
>
> - 与开发人员沟通，获取接口的基本信息。
> - 使用抓包工具（如Fiddler或Charles）分析请求和响应数据。
> - 根据实际需求手动设计测试用例。
>
> 



#### [UI自动化测试](https://metaso.cn/search/8598929189213294592/interactive?dataId=8598929189330735104&targetType=0)

> Q：**上家公司做自动化测试使用的框架**
>
> python+selenium+pytest
>
> 
>
> Q：**自动化测试流程**
>
> 1.编写自动化测试计划
>
> 2.设计自动化测试用例
>
> 3.编写自动化测试框架和脚本
>
> 4.调试和维护脚本
>
> 5.无人值守测试
>
> 6.后期脚本维护
>
> 
>
> Q：**如何判断一个页面上元素是否存在？**
>
> 1. 使用find_element
> 2. 使用try except
>
> 
>
> Q：如何通过子元素定位父元素
>
> 1. 使用 XPath 的 parent:: 或 ..
>
>    - **方法**：通过子元素的定位表达式，使用 parent:: 或 .. 定位到父节点。
>
>    - **优点**：灵活，支持复杂定位，兼容性好。
>
>    - .. 表示当前节点的父节点，等效于 parent::*。
>
>    - 可以进一步限定父元素类型，如 parent::div 只匹配 <div> 父节点。
>
> 2. 使用 XPath 的祖先节点（ancestor::）
>    - **方法**：如果需要定位更上层的父节点（不仅是直接父节点），使用 ancestor::。
>    - **优点**：可跳跃定位到特定层级的父节点。
>    - ancestor::div[1] 表示离子元素最近的 <div> 祖先，[2] 表示上两层的 <div>。
>
> **默认推荐**：方法1（XPath .. 或 parent::），简单可靠，适用大多数场景。
>
> **复杂结构**：方法2（ancestor::），适合定位非直接父节点。
>
> **性能敏感**：方法3（CSS + XPath），CSS 定位子元素更快。
>
> **特殊需求**：方法4（JavaScript），处理复杂 DOM 操作。
>
> 
>
> Q：如何截取一个元素的图片而不是截取全部的图片
>
> 方法：定位元素 + 全屏截图 + 裁剪
>
> 1. 定位目标元素：使用 Selenium 定位到需要截图的元素。
> 2. 获取元素位置和大小：通过 location 和 size 属性获取元素的坐标和尺寸。
> 3. 截取全屏：使用 Selenium 的 get_screenshot_as_png 获取整个页面截图。
> 4. 裁剪图片：使用 Pillow 库裁剪出目标元素区域。
> 5. 保存图片：将裁剪后的图片保存到指定路径。
>
> 
>
> Q：**自动化测试的价值在哪里**
>
> 1.使用了自动化测试以后，能替代大量重复繁琐的回归测试工作
>
> 2.能解放测试人员，然后让测试人员把精力放到其他复杂的业务功能上
>
> 3.自动化测试一般是对稳定下来的功能进行回归的自动化测试，保证不会因为功能更新而导致之前稳定的共嗯出问题
>
> 
>
> Q：**自动化测试有误报过bug吗**
>
> 1.有误报过的，有的时候自动化测试中显示了bug，但是实际通过手工测试去确认又不存在
>
> 2.主要原因大概是：元素定位不稳定或者开发更新了页面但是测试没有及时更新维护
>
> 
>
> Q：**举例说明，都有哪些功能可以用自动化来进行？**
>
> 回归测试：检验新变更是否影响现有功能
>
> 冒烟测试：验证基本功能是否正常工作
>
> 接口测试：验证API响应和数据正确性
>
> 数据驱动测试：相同测试流程使用多组数据
>
> 登录验证：不同账号权限的登录测试
>
> 表单验证：大量输入字段的有效性检查
>
> 性能测试：负载测试、压力测试、并发测试
>
> 兼容性测试：不同浏览器/设备/系统的测试
>
> 定时任务：检查系统定时作业是否正常执行
>
> 
>
> Q：**如何判断一个功能能否进行自动化测试？**
>
> 执行频率：高频执行的测试更适合自动化
>
> 稳定性：功能本身稳定，变动不频繁
>
> 技术可行性：技术上可以实现自动化
>
> 投资回报：自动化带来的收益大于成本
>
> 测试复杂度：测试步骤可以清晰定义
>
> 测试数据：能否生成或获取足够测试数据
>
> 环境因素：测试环境是否支持自动化
>
> 
>
> Q：**定位xpath路径都有哪些方法？**
>
> 绝对路径：从根节点到目标元素的完整路径 (`/html/body/div/span`)
>
> 相对路径：以双斜线开始的相对定位 (`//div[@id='login']`)
>
> 属性定位：通过元素属性定位 (`//input[@name='username']`)
>
> 文本定位：通过元素文本内容定位 (`//button[text()='登录']`)
>
> 包含文本：定位包含特定文本的元素 (`//div[contains(text(),'欢迎')]`)
>
> 包含属性：定位包含特定属性的元素 (`//input[contains(@class,'btn')]`)
>
> 索引定位：通过位置索引定位 (`//div[@class='item'][1]`)
>
> 
>
> Q：**如何定位一个动态的元素？**
>
> 使用部分ID/class定位：`//div[contains(@id,'login_')]`
>
> 使用稳定的父元素定位：`//div[@id='stable-parent']//input`
>
> 使用相邻元素定位：`//label[text()='用户名']/following-sibling::input`
>
> 使用CSS选择器匹配部分属性：`css=input[id*='part_of_id']`
>
> 使用XPath的starts-with函数：`//div[starts-with(@id,'prefix_')]`
>
> 使用XPath的ends-with函数：`//div[ends-with(@id,'_suffix')]`
>
> 使用相对稳定的属性：如name、type、placeholder等
>
> 使用元素的位置关系：父子、兄弟、祖先等
>
> 等待元素出现后再定位：使用显式或隐式等待
>
> 
>
> Q：**如何定位类似于悬浮在web页面上的元素（类似于web上飞来飞去的广告）**
>
> 使用z-index属性定位：`//div[contains(@style,'z-index')]`
>
> 定位iframe内的元素：广告常在iframe中，先切换到iframe再定位
>
> 使用position属性定位：`//div[contains(@style,'position:fixed')]`
>
> 通过可见性等待：使用WebDriverWait等待元素可见
>
> 使用JavaScript执行器定位：`document.getElementsByClassName('ad-class')`
>
> 使用元素特征定位：广告通常有特定class或id模式
>
> 通过事件处理：在元素出现时捕获事件
>
> 通过截图对比：检测页面变化来定位动态元素
>
> 使用特殊框架API：如Selenium的Actions类处理悬浮元素
>
> 
>
> Q：**列举你知道的自动化测试工具**
>
> Web自动化：Selenium、RPA
>
> 移动应用测试：Appium
>
> API测试：Postman、Apifox、JMeter、SoapUI、Karate
>
> 性能测试：JMeter、LoadRunner、Gatling、Locust、K6
>
> 单元测试：JUnit、Pytest
>
> 持续集成：Jenkins、GitHub Actions、Travis CI、CircleCI、GitLab CI
>
> 
>
> **Q：selenium框架的运行原理**
>
> WebDriver（浏览器驱动）：
>
> - WebDriver 是 Selenium 的核心组件，它充当测试脚本和浏览器之间的桥梁。
> - 针对不同的浏览器（如 Chrome、Firefox、Edge 等），需要使用相应的 WebDriver 驱动程序。
> - WebDriver 驱动程序接收来自测试脚本的命令，并将其转换为浏览器可以理解的指令。
>
> 浏览器：
>
> - 浏览器接收到 WebDriver 驱动程序发送的指令后，执行相应的操作。
> - 例如，如果指令是“点击按钮”，浏览器就会模拟用户点击按钮的动作。
> - 浏览器执行操作后，将结果返回给 WebDriver 驱动程序。
>
> 
>
> **Q：selenium定位元素的方法都有哪些**
>
> 绝对路径：从根节点到目标元素的完整路径 (`/html/body/div/span`)
>
> 相对路径：以双斜线开始的相对定位 (`//div[@id='login']`)
>
> 属性定位：通过元素属性定位 (`//input[@name='username']`)
>
> 文本定位：通过元素文本内容定位 (`//button[text()='登录']`)
>
> 包含文本：定位包含特定文本的元素 (`//div[contains(text(),'欢迎')]`)
>
> 包含属性：定位包含特定属性的元素 (`//input[contains(@class,'btn')]`)
>
> 索引定位：通过位置索引定位 (`//div[@class='item'][1]`)
>
> 
>
> **7. 什么是数据驱动测试？它有哪些优点？**
>
> - **答案：** 数据驱动测试是指使用外部数据源（如 Excel、CSV）驱动测试用例的执行。
> - 优点：
>   - 提高测试覆盖率：可以使用不同的数据组合测试同一个测试用例。
>   - 提高测试效率：可以批量执行测试用例，减少重复工作。
>   - 提高测试可维护性：测试数据和测试逻辑分离，便于维护。
>
> 
>
> **8. 自动化测试的测试报告，应该包含哪些内容？**
>
> - 答案：
>
>    自动化测试报告应包含：
>
>   - 测试用例执行结果（通过、失败、跳过）。
>   - 测试执行时间。
>   - 失败用例的详细信息（错误信息、堆栈跟踪）。
>   - 测试覆盖率。
>   - 测试环境信息。
>   - 测试人员，测试日期等信息。
>
> 
>
> **9. 如何提高自动化测试的稳定性？**
>
> - 答案：
>
>    提高自动化测试稳定性的方法包括：
>
>   - 编写健壮的定位器。
>   - 使用显式等待。
>   - 处理异常情况。
>   - 使用稳定的测试数据。
>   - 尽量避免使用Thread.sleep()。
>   - 保持测试环境的稳定。
>
> 
>
> **10. 自动化测试的维护成本有哪些？如何降低维护成本？**
>
> - 答案：
>
>    自动化测试的维护成本包括：
>
>   - 测试用例的维护。
>   - 测试环境的维护。
>   - 测试数据的维护。
>
> - 降低维护成本的方法：
>
>   - 编写可维护的测试代码。
>   - 使用合适的测试框架。
>   - 保持测试环境的稳定。
>   - 使用数据驱动测试，减少重复代码。
>   - 做好代码的分层，以及封装。



#### 性能测试

> Q：**性能测试如何做的？**
>
> 需求分析：确定性能指标和测试目标
>
> 测试计划：定义测试场景、负载模型和测试环境
>
> 脚本开发：编写性能测试脚本（如JMeter、LoadRunner）
>
> 环境准备：配置测试环境、监控工具和数据收集方式
>
> 基准测试：建立系统基准性能
>
> 负载测试：逐步增加用户负载，监测系统表现
>
> 压力测试：测试系统在极限负载下的表现
>
> 稳定性测试：长时间运行系统验证稳定性
>
> 数据分析：分析响应时间、吞吐量、资源使用率等
>
> 瓶颈定位：发现系统瓶颈并提出优化建议
>
> 优化验证：验证优化措施的效果
>
> 测试报告：生成完整的性能测试报告
>
> 
>
> Q：**性能测试需要关注哪些方面？**
>
> 响应时间：用户请求的响应速度
>
> 吞吐量：系统单位时间处理的事务数量（TPS/QPS）
>
> 并发用户数：系统能够同时支持的用户数量
>
> 资源利用率：CPU、内存、磁盘I/O、网络带宽使用情况
>
> 稳定性：系统长时间运行的可靠性
>
> 瓶颈点：系统中的性能瓶颈和限制因素
>
> 错误率：系统在负载下的错误发生率
>
> 数据库性能：SQL执行时间、连接数、缓存命中率
>
> 扩展性：系统处理能力随资源增加的变化情况
>
> 敏感操作：特定关键业务操作的性能
>
> 负载均衡：多服务器环境下的负载分布情况
>
> 缓存效率：缓存系统的命中率和响应时间



#### 排查问题的思路

> Q：**网页崩溃的原因是什么？**
>
> JavaScript错误：未捕获的异常或无限循环
>
> 内存泄漏：长时间运行导致内存累积
>
> DOM操作过多：频繁或大量DOM操作导致浏览器无响应
>
> 插件冲突：浏览器插件与网页脚本冲突
>
> 资源过大：加载过大的图片或视频文件
>
> 网络问题：请求超时或网络不稳定
>
> 
>
> Q：**有个用户反馈上传头像失败，分析原因？**
>
> 文件大小：超出系统允许的最大上传大小
>
> 文件格式：不支持的图片格式（非JPG/PNG等）
>
> 网络问题：上传过程中网络不稳定或中断
>
> 服务器限制：服务器配置限制（如PHP的upload_max_filesize）
>
> 权限问题：存储目录权限不足
>
> 磁盘空间：服务器存储空间不足
>
> 会话超时：上传过程中用户会话过期
>
> 前端验证：前端JavaScript验证错误
>
> 浏览器兼容性：特定浏览器的上传功能问题
>
> 防病毒软件：客户端安全软件拦截上传
>
> 服务器负载：服务器过载无法处理上传请求
>
> 第三方服务问题：如使用云存储服务出现故障
>
> 
>
> Q：**app闪退的原因？**
>
> 内存溢出（OOM）：应用占用内存过多
>
> 未捕获的异常：代码中存在未处理的异常
>
> 线程问题：主线程阻塞或线程同步问题
>
> 系统版本兼容性：应用与特定系统版本不兼容
>
> 资源访问权限：缺少必要的权限（如相机、存储等）
>
> 硬件兼容性：特定设备的硬件不兼容
>
> 网络问题：网络请求处理不当
>
> 过度频繁的UI更新：造成UI渲染负担过重
>
> 数据库操作错误：数据库读写异常
>
> 第三方库冲突：集成的第三方SDK冲突
>
> 应用配置错误：应用配置文件错误
>
> 系统资源不足：设备资源（如RAM）不足
>
> 
>
> Q：**网页卡顿的原因是什么？**
>
> JavaScript执行效率低：长时间运行的JS阻塞主线程
>
> DOM操作频繁：过多或低
>
> 
>
> Q：**10%的用户反馈用不了功能，你讲如何排查？**
>
> 数据收集和分析
>
> - 确认具体是哪些功能无法使用
> - 收集这10%用户的共同特征（使用设备、系统版本、地理位置、账户类型等）
> - 分析错误日志和用户行为数据
> - 查看问题是从什么时间开始出现的
>
> 环境因素排查
>
> - 检查这些用户是否使用特定的浏览器/设备/操作系统
> - 确认是否有特定的网络环境限制（公司防火墙、区域性限制等）
> - 检查是否与第三方插件或安全软件冲突
>
> 账户权限排查
>
> - 验证这些用户的权限设置是否正确
> - 检查账户状态（是否处于特殊状态或受限模式）
> - 确认是否有用户分组或特征标签影响功能访问
>
> 技术层面排查
>
> - 检查最近的代码更新是否影响了特定用户群体
> - 验证API调用是否对部分用户失败
> - 排查缓存或会话管理问题
> - 检查数据库访问是否存在问题
>
> 
>
> Q：**登录的按钮不能点击，如何排查问题？**
>
> 检查前端代码和样式问题
>
> - 查看按钮是否被其他元素覆盖（z-index问题）
> - 检查按钮的点击区域是否正确设置
> - 确认按钮的禁用状态(disabled属性)是否被错误设置
> - 检查CSS样式是否有pointer-events: none的设置
>
> 验证交互逻辑
>
> - 确认是否有JavaScript逻辑在阻止点击事件
> - 检查表单验证逻辑是否正确，是否在表单未完成时禁用按钮
> - 验证事件监听器是否正确绑定到按钮上
>
> 测试不同场景
>
> - 在不同浏览器中测试（Chrome, Firefox, Safari等）
> - 在不同设备上测试（桌面端、移动端）
> - 测试不同网络环境下的表现
>
> 检查与后端交互
>
> - 查看网络请求是否有错误导致前端锁定按钮
> - 确认API响应是否正常
> - 检查是否有防止重复提交的逻辑导致按钮被锁定
>
> 用户权限和状态检查
>
> - 确认用户是否有登录权限
> - 检查用户账户状态是否正常
> - 验证是否有IP或地区限制
>
> 应用程序状态
>
> - 检查应用是否处于维护模式
> - 确认服务器状态是否正常
> - 检查是否有全局错误影响UI交互
>
> 开发者工具调试
>
> - 使用浏览器开发者工具检查控制台错误
> - 检查元素检查器中按钮的实际状态
> - 尝试在控制台中手动触发点击事件看是否有响应
>
> 
>
> Q：**压测的时候，QPS一直上不去，你会怎么排查？**
>
> 检查压测工具配置
>
> - 确认压测工具本身的配置是否正确（线程数、连接数等）
> - 验证压测机器的资源是否足够（CPU、内存、网络带宽）
> - 检查是否压测工具本身成为了瓶颈
>
> 网络层面排查
>
> - 检查网络带宽是否成为限制
> - 确认网络连接数是否达到上限
> - 查看是否有网络延迟或丢包
> - 排查防火墙或负载均衡器的限制
>
> 系统资源监控
>
> - CPU使用率（是否接近100%）
> - 内存使用情况（是否有大量交换）
> - 磁盘I/O（是否出现I/O等待）
> - 网络I/O（是否达到网卡极限）
>
> 应用层面排查
>
> - 线程池配置是否合理
> - 数据库连接池设置是否适当
> - JVM参数是否优化（如果是Java应用）
> - 应用是否有锁竞争或同步瓶颈
>
> 数据库排查
>
> - 慢查询分析
> - 数据库连接数是否达到限制
> - 索引使用是否合理
> - 事务锁定情况
>
> 中间件检查
>
> - 缓存使用情况（如Redis、Memcached）
> - 消息队列处理能力（如Kafka、RabbitMQ）
> - API网关或服务网格限流设置
>
> 系统架构分析
>
> - 识别系统中的串行处理部分
> - 检查是否存在单点瓶颈
> - 评估系统的可扩展性设计
>
> 日志和监控指标分析
>
> - 检查错误日志和异常
> - 分析关键性能指标
> - 利用APM工具（如Skywalking、Pinpoint）定位瓶颈
>
> 
>
> Q：**APP提示无法连接网络，你会如何排查？**
>
> 基础网络连接检查
>
> - 确认设备是否真的已连接到WiFi或移动数据
> - 测试其他应用是否能正常连接网络
> - 尝试访问知名网站（如百度）验证网络连通性
> - 检查是否开启了飞行模式
>
> APP特定问题排查
>
> - 检查APP是否有网络权限
> - 确认是否对特定APP限制了后台数据使用
> - 检查APP版本是否为最新版本
> - 尝试清除APP缓存和数据后重试
> - 卸载并重新安装APP
>
> 网络环境问题
>
> - 尝试切换WiFi和移动数据
> - 检查WiFi信号强度
> - 测试不同的网络环境（如其他WiFi网络）
> - 重启路由器/调制解调器
> - 检查DNS设置是否正常
>
> 设备问题排查
>
> - 重启设备
> - 检查设备时间和日期设置是否正确
> - 检查设备存储空间是否充足
> - 更新设备系统版本
> - 检查是否安装了影响网络的软件（如VPN、防火墙）
>
> 特定网络限制检查
>
> - 确认网络是否有防火墙限制
> - 检查公司/学校网络是否限制了特定应用
> - 检查IP是否被封禁
> - 验证服务器区域访问限制
>
> 服务器端问题
>
> - 检查APP服务器状态（可通过官方社交媒体或状态页面）
> - 查看是否有其他用户报告类似问题
> - 联系APP客服了解是否有已知服务中断
>
> 
>
> Q：**怎么判断一个BUG到底是前端的BUG还是后端的BUG？**
>
> 数据不正确但格式正确：通常是后端问题
>
> 数据格式错误或解析错误：可能是前后端接口定义不一致
>
> 界面渲染问题：通常是前端问题
>
> 服务器报错(500等)：通常是后端问题
>
> 请求未到达服务器：可能是前端问题或网络问题
>
> 我会采用隔离测试法，使用像Postman这样的工具直接测试后端API，确认原始数据是否正确。同时，我会检查前端日志和后端日志，寻找错误信息。我还会考虑重现步骤、环境因素，并进行比较测试（不同浏览器、不同设备）来缩小问题范围。当确认问题后，我会建立详细的复现文档，包括环境信息、操作步骤、预期结果与实际结果的对比，以及相关的网络请求和响应数据，帮助开发团队快速定位问题。



#### 实战案例

> **Q：微博发动态，设计一下测试点**
>
> **1. 功能性测试：**
>
> - 文本内容：
>   - 正常文本输入：测试各种字符类型（中文、英文、数字、特殊字符）、长度限制（最大字符数、最小字符数）、换行、空格等。
>   - 特殊文本输入：测试表情符号、@用户、#话题#、URL链接、HTML标签、JavaScript代码等。
>   - 文本编辑：测试复制、粘贴、剪切、撤销、重做等功能。
>   - 敏感词过滤：测试是否能正确过滤敏感词汇。
> - 图片/视频：
>   - 图片上传：测试不同格式（JPG、PNG、GIF等）、大小、分辨率的图片上传，多图上传、图片裁剪、图片旋转等。
>   - 视频上传：测试不同格式（MP4、AVI等）、大小、时长的视频上传。
>   - 图片/视频与文本同时上传测试。
>   - 图片/视频删除测试。
> - 定位：
>   - 定位功能：测试能否准确获取地理位置、搜索附近地点、选择地点等。
>   - 定位权限测试，无权限是否能正常发布。
> - 可见性：
>   - 可见范围：测试公开、私密、分组可见等选项是否生效。
> - 发布操作：
>   - 发布按钮：测试点击发布按钮后的状态、发布成功/失败的提示信息。
>   - 发布后，内容是否正确显示在个人主页。
>   - 发布后，内容是否正确推送到粉丝时间线。
>   - 测试网络异常，发布失败的情况。
>
> **2. 性能测试：**
>
> - 响应时间：
>   - 测试发布动态的响应时间，包括文本、图片、视频等不同情况。
>   - 测试高并发情况下，发布动态的响应时间。
> - 资源消耗：
>   - 测试发布动态时CPU、内存、网络等资源消耗情况。
>
> **3. 安全性测试：**
>
> - XSS攻击：
>   - 测试是否能通过输入特殊字符或代码进行XSS攻击。
> - SQL注入：
>   - 测试是否能通过输入特殊字符进行SQL注入。
> - 权限控制：
>   - 测试未授权用户是否能发布动态。
> - 数据安全：
>   - 测试用户发布的内容是否被正确存储和保护。
>
> **4. 兼容性测试：**
>
> - 浏览器兼容性：
>   - 测试在不同浏览器（Chrome、Firefox、Safari、Edge等）下的显示和功能是否正常。
> - 移动端兼容性：
>   - 测试在不同操作系统（iOS、Android）和不同分辨率的移动设备上的显示和功能是否正常。
>
> **5. 用户体验测试：**
>
> - 界面布局：
>   - 测试界面布局是否合理、美观。
> - 操作流程：
>   - 测试发布动态的操作流程是否简洁、易用。
> - 提示信息：
>   - 测试提示信息是否清晰、易懂。
>
> **6. 异常测试：**
>
> - 网络异常：
>   - 测试在网络不稳定或断开的情况下发布动态的表现。
> - 服务器异常：
>   - 测试在服务器故障或维护的情况下发布动态的表现。
> - 输入异常：
>   - 测试输入超长文本，超大图片，不支持的视频格式等情况下，发布动态的表现
>
> 
>
> **Q：对一台自动售货机进行测试用例设计**
>
> **功能性测试：**
>
> - 商品选择：
>   - 测试能否正确选择不同商品。
>   - 测试选择不存在的商品，是否给出正确提示。
>   - 测试选择商品后，商品信息（名称、价格）是否正确显示。
>   - 测试商品库存不足时，是否给出正确提示。
> - 投币/支付：
>   - 测试能否正确识别不同面额的硬币/纸币。
>   - 测试能否识别假币/无效货币。
>   - 测试支持的支付方式（微信、支付宝、银行卡等）是否能正常使用。
>   - 测试支付金额是否正确扣除。
>   - 测试支付过程中断，是否能正确退款。
>   - 测试能否正确找零。
> - 出货：
>   - 测试能否正确出货。
>   - 测试出货过程中卡住商品，是否给出正确提示。
>   - 测试出货后，商品库存是否正确更新。
>   - 测试出货口是否安全，防止夹手等危险。
> - 显示屏：
>   - 测试显示屏能否正常显示商品信息、价格、支付信息、提示信息等。
>   - 测试显示屏在不同光线条件下，是否清晰可见。
>   - 测试广告播放是否正常，声音是否正常。
> - 退币：
>   - 测试退币按钮是否正常工作。
>   - 测试是否能正确退回投入的硬币。
>   - 测试在各种情况下，退币功能是否正常。
>
> **2. 性能测试：**
>
> - 响应时间：
>   - 测试选择商品、支付、出货等操作的响应时间。
>   - 测试在高并发情况下，自动售货机的响应时间。
> - 稳定性：
>   - 测试自动售货机在长时间运行下的稳定性。
>   - 测试在各种温度，湿度下，是否能稳定运行。
>
> **3. 安全性测试：**
>
> - 支付安全：
>   - 测试支付过程中的数据加密和安全传输。
>   - 测试防止支付漏洞，如重复支付、恶意支付等。
> - 防盗安全：
>   - 测试自动售货机的防盗性能，如防撬、防破坏等。
>   - 测试监控系统是否正常工作，是否能记录异常情况。
> - 食品安全：
>   - 测试售卖食品的自动售货机，是否符合食品安全标准。
>   - 测试自动售货机的温度控制，是否能保证食品质量。
>
> **4. 兼容性测试：**
>
> - 支付方式兼容性：
>   - 测试自动售货机支持的各种支付方式的兼容性。
> - 货币兼容性：
>   - 测试自动售货机支持的各种货币的兼容性。
> - 环境兼容性：
>   - 测试在不同的环境温度，湿度下，自动售货机是否能正常工作。
>
> **5. 用户体验测试：**
>
> - 操作界面：
>   - 测试操作界面是否简洁、易懂。
>   - 测试操作流程是否流畅。
> - 提示信息：
>   - 测试提示信息是否清晰、准确。
> - 易用性：
>   - 测试自动售货机是否易于使用，是否符合人体工程学。
>
> **6. 异常测试：**
>
> - 断电：
>   - 测试断电后，自动售货机是否能恢复正常工作。
>   - 测试断电后，是否会造成资金损失。
> - 网络异常：
>   - 测试网络异常情况下，支付功能是否能正常工作。
>   - 测试网络异常情况下，后台数据是否会丢失。
> - 硬件故障：
>   - 测试硬件故障情况下，自动售货机是否能给出正确提示。
>   - 测试硬件故障情况下，是否会造成资金损失。
>
> 
>
> **Q：设计微信扫码支付的测试用例**
>
> **扫码功能：**
>
> - 测试能否正确扫描不同清晰度、大小的二维码。
> - 测试在不同光线条件下，能否正常扫码。
> - 测试能否扫描其他平台的二维码，是否给出正确提示。
> - 测试能否扫描无效的二维码，是否给出正确提示。
>
> **支付流程：**
>
> - 测试扫描二维码后，能否正确显示商品信息和价格。
> - 测试能否正确选择支付方式（微信零钱、银行卡等）。
> - 测试输入正确的支付密码，能否完成支付。
> - 测试输入错误的支付密码，能否给出正确提示。
> - 测试支付过程中断，是否能取消支付。
> - 测试支付成功后，能否正确显示支付结果。
> - 测试支付成功后，能否在微信支付记录中查到交易信息。
> - 测试支付成功后，商家是否能收到支付信息。
>
> **金额校验：**
>
> - 测试支付金额与商品金额是否一致。
> - 测试输入负数金额，或0元能否正确拦截。
>
> **交易状态：**
>
> - 测试交易成功，失败，交易关闭等状态是否能正确显示。
> - 测试交易关闭后，是否能重新发起支付。
>
> **退款功能：**
>
> - 测试能否发起退款。
> - 测试退款金额是否正确。
> - 测试退款后，用户是否能收到退款。
> - 测试退款后，商家是否能收到退款信息。
>
> 
>
> **Q：如果手机浏览器输入 baidu.com打不开页面，你会怎么排查？**
>
> **1. 网络连接检查：**
>
> - 确认网络状态：
>   - 首先，检查手机是否已连接到互联网（Wi-Fi 或移动数据）。
>   - 尝试打开其他网站或应用程序，确认网络连接是否正常。
>   - 如果使用 Wi-Fi，尝试重启路由器或连接其他 Wi-Fi 网络。
>   - 如果使用移动数据，确认信号强度是否良好，尝试切换到Wi-Fi。
> - 检查网络设置：
>   - 检查手机的网络设置，确保没有启用代理服务器或 VPN。
>   - 尝试关闭并重新打开 Wi-Fi 或移动数据。
>   - 尝试飞行模式开关，然后关闭，重新建立网络连接。
>
> **2. 浏览器问题排查：**
>
> - 清除浏览器缓存和 Cookie：
>   - 浏览器缓存和 Cookie 可能会导致网页加载问题。尝试清除浏览器缓存和 Cookie。
>   - 尝试使用浏览器的隐私模式，看是否可以打开。
> - 尝试其他浏览器：
>   - 尝试使用其他手机浏览器（如 Chrome、Firefox、Safari 等）打开 `baidu.com`，以确定是否是特定浏览器的问题。
>   - 如果其他浏览器可以打开，则可能是原浏览器存在问题，尝试更新或重装浏览器。
> - 检查浏览器设置：
>   - 检查浏览器设置，确保 JavaScript 已启用。
>   - 尝试禁用浏览器插件或扩展程序，看是否能解决问题。
> - 检查浏览器版本：
>   - 确保浏览器是最新版本，旧版本可能存在兼容性问题。
>
> **3. DNS 问题排查：**
>
> - 尝试更改 DNS 服务器：
>   - DNS 服务器负责将域名解析为 IP 地址。如果 DNS 服务器出现问题，可能导致无法打开网页。
>   - 尝试将手机的 DNS 服务器更改为公共 DNS 服务器（如 Google DNS 8.8.8.8 和 8.8.4.4，或 Cloudflare DNS 1.1.1.1 和 1.0.0.1）。
> - 清除 DNS 缓存：
>   - 尝试清除手机的DNS缓存。
>
> **4. 网站问题排查：**
>
> - 尝试使用 IP 地址访问：
>   - 尝试使用 `baidu.com` 的 IP 地址（可以通过在电脑上 ping `baidu.com` 获取）直接在浏览器中访问，以确定是否是 DNS 解析问题。
> - 检查网站状态：
>   - 使用网站状态检查工具（如 Down for Everyone or Just Me）检查 `baidu.com` 是否正常运行。
> - 尝试在其他设备上访问：
>   - 尝试在其他手机或电脑上访问`baidu.com`,确认是否仅是当前设备的问题。
>
> **5. 手机系统问题排查：**
>
> - 重启手机：
>   - 重启手机可以解决一些临时性的软件问题。
> - 更新手机系统：
>   - 确保手机系统是最新版本，旧版本可能存在兼容性问题。
> - 检查防火墙或安全软件：
>   - 查看手机是否安装有防火墙或者安全软件，确认是否拦截了浏览器的网络请求。
>
> **6. 其他可能的原因：**
>
> - 运营商问题：
>   - 可能是运营商的网络问题导致无法访问特定网站。
> - 手机硬件问题：
>   - 极少数情况下，手机硬件问题也可能导致网络连接问题。
>
> 
>
> **Q：设计输入框测试用例？**
>
> **功能性测试：**
>
> - 字符类型：验证允许和禁止的字符。
> - 长度限制：测试边界值和超长输入。
> - 输入格式：验证特定格式（如邮箱、电话）的正确性。
> - 必填项：验证未输入时的提示。
> - 特殊字符：测试特殊字符的处理和安全性。
> - 敏感词过滤：验证是否对敏感词汇有正确的过滤。
>
> **安全性测试：**
>
> - XSS 和 SQL 注入：防止恶意代码和注入。
> - 数据安全：验证输入数据的加密。
>
> **兼容性测试：**
>
> - 浏览器和移动端：验证在不同平台上的显示和功能。
>
> **用户体验测试：**
>
> - 界面布局和提示信息：确保易用性和清晰度。
>
> **异常测试：**
>
> - 网络和服务器异常：测试在异常情况下的表现。
>
> 
>
> **Q：编写一个登录界面的测试用例？**
>
> **功能性测试：**
>
> - 正常登录：
>   - 输入正确的用户名和密码，验证是否能成功登录。
>   - 测试用户名和密码的大小写敏感性。
> - 异常登录：
>   - 输入错误的用户名，验证是否给出错误提示。
>   - 输入错误的密码，验证是否给出错误提示。
>   - 用户名或密码为空，验证是否给出错误提示。
>   - 输入特殊字符，验证是否能正确处理。
>   - 连续多次输入错误密码，验证是否触发账户锁定机制。
> - 找回密码：
>   - 测试“忘记密码”链接是否能正确跳转到找回密码页面。
>   - 验证找回密码流程是否正确。
> - 记住密码：
>   - 勾选“记住密码”选项，验证下次打开页面是否自动填充用户名和密码。
>   - 验证记住密码的有效期。
> - 验证码：
>   - 验证码功能，验证输入错误验证码时能否登录失败，并刷新验证码。
>   - 验证码的刷新机制，刷新后验证码是否有效。
>
> **2. 安全性测试：**
>
> - 密码安全性：
>   - 验证密码是否以星号或圆点显示。
>   - 验证密码是否限制复制粘贴。
>   - 验证密码在网络传输过程中是否加密。
>   - 验证密码在数据库中是否加密存储。
> - 防暴力破解：
>   - 测试连续多次输入错误密码，是否触发账户锁定机制。
>   - 测试验证码机制是否能有效防止暴力破解。
> - 会话管理：
>   - 验证登录后，会话是否安全管理。
>   - 验证退出登录后，会话是否正确销毁。
> - SQL注入：
>   - 测试登录界面是否能防止SQL注入。
>
> **3. 性能测试：**
>
> - 响应时间：
>   - 测试登录界面的加载时间。
>   - 测试登录操作的响应时间。
>   - 在高并发情况下，测试登录操作的响应时间。
> - 资源消耗：
>   - 测试登录界面在不同浏览器和设备上的资源消耗。
>
> **4. 兼容性测试：**
>
> - 浏览器兼容性：
>   - 测试登录界面在不同浏览器（Chrome、Firefox、Safari、Edge等）下的显示和功能是否正常。
> - 移动端兼容性：
>   - 测试登录界面在不同操作系统（iOS、Android）和不同分辨率的移动设备上的显示和功能是否正常。
>
> **5. 用户体验测试：**
>
> - 界面布局：
>
>   - 测试登录界面的布局是否合理、美观。
>   - 测试提示信息是否清晰、易懂。
>
> - 易用性：
>
>   - 测试登录界面是否易于使用。
>





#### Python

> **Q：全局变量和局部变量变量名能否一样？**
>
> 在大多数编程语言中，遵循以下规则：
>
> 1. 在局部作用域内声明的同名局部变量会暂时"遮蔽"全局变量
> 2. 局部变量的作用域结束后，全局变量的访问会恢复
> 3. 不同的局部作用域可以各自有同名的局部变量，互不影响
>
> 
>
> **Q：Python 里 is 和 == 的区别？**
>
> Python中`is`和`==`的区别在于它们比较的内容不同：
>
> - `==`比较两个对象的值是否相等（值相等性）
> - `is`比较两个变量是否引用同一个对象（身份相等性）
> - 
>
> **Q：Python 变量的创建与消亡过程**
>
> 创建变量时，Python 会在内存中创建对象，并将变量名指向这个对象。消亡过程主要与垃圾回收相关，当没有任何变量引用某个对象时，该对象就会被垃圾回收机制清理。
>
> 
>
> **Q：Python的垃圾回收的机制**
>
> Python 使用引用计数和垃圾回收机制（主要是循环垃圾回收）来管理内存。引用计数会统计一个对象的引用次数，当引用次数为0时，该对象会被销毁。对于循环引用，Python 会使用垃圾回收器来检测并清理。
>
> 
>
> **Q：dict的底层结构，tuple和list的底层结构的区别**
>
> **dict**: 基于哈希表实现，能够根据键值对存储数据，具有常数时间复杂度 O(1) 来进行查找、插入和删除操作。
>
> **tuple**: 基于数组实现，是一个不可变类型。由于不可变，元组的性能要比列表更优。
>
> **list**: 也是基于动态数组实现，支持增删改查，随着元素的增多，可能需要重新分配内存。
>
> 
>
> **Q：深拷贝浅拷贝的区别是什么？**
>
> **浅拷贝**：复制对象本身，但不复制其包含的子对象（即子对象仍指向原对象的引用）。
>
> **深拷贝**：不仅复制对象本身，还递归地复制对象内部的所有子对象，确保完全独立。
>
> 
>
> **Q：什么是装饰器？举一个你用过装饰器的例子**
>
> 装饰器是一个接受函数或方法并返回一个新函数的函数。它通常用于增强原函数的功能，不修改原函数代码。
>
> ```python
> def decorator(func):
>     def wrapper():
>         print("Before function")
>         func()
>         print("After function")
>     return wrapper
> 
> @decorator
> def say_hello():
>     print("Hello!")
> ```
>
> 
>
> **Q：@classmethod 和 @staticmethod 的区别，以及分别运用在哪些使用场景？**
>
> **@classmethod**：表示方法的第一个参数是类（cls），可以通过类来访问类的属性和方法。通常用于工厂方法、修改类属性等。
>
> **@staticmethod**：不依赖于实例或类，只是一个普通的函数，不能访问类或实例的属性。通常用于工具函数。
>
> 
>
> **Q：什么是鸭子类型？**
>
> 鸭子类型是指只关心对象是否具有某个方法或属性，而不关心对象的具体类型。例如，`if hasattr(obj, 'fly'):`，如果对象 `obj` 有 `fly` 方法，哪怕它的类型不是鸟类，也可以执行。
>
> 
>
> **Q：python 的可变类型有哪些？**
>
> - Python 中的可变类型包括：`list`, `dict`, `set`, 自定义对象（通过修改对象的属性）。
>
> 
>
> **Q：python 常见的数据类型有哪些？**
>
> Python 常见的数据类型有：
>
> - 基本数据类型：`int`, `float`, `str`, `bool`
> - 容器类型：`list`, `tuple`, `set`, `dict`
> - 特殊类型：`NoneType`（None），`complex`
>
> 
>
> **Q：列举 python2 和 python3 的区别**
>
> Python3 中字符串默认为 Unicode，而 Python2 默认是 ASCII。
>
> Python2 中 `print` 是一个语句，而在 Python3 中是一个函数 `print()`.
>
> Python3 中整数除法结果是浮动数，Python2 中整数除法是地板除。
>
> 
>
> **Q：什么是lambda函数？怎么用？**
>
> `lambda` 函数是一个匿名函数，常用于定义简单的、只包含一行表达式的函数。例如：
>
> ```python
> add = lambda x, y: x + y
> ```
>
> Lambda表达式是Python中的一种匿名函数，它可以在一行代码中定义函数并立即调用它。与普通函数不同的是，Lambda函数通常不需要使用def关键字去定义，而是在需要时直接使用lambda关键字来创建。Lambda函数可以接受任意数量的参数，但只能返回一个表达式的结果。
>
> 
>
> **Q：别的编程语言都有三目运算符，三目运算符在python中怎么表达？**
>
> Python 使用条件表达式来表示三目运算符：
>
> ```python
> x = 10 if condition else 20
> ```
>
> 
>
> **Q：try...except...else 和 try...except...finally 的区别是什么？**
>
> **try...except...else**: `else` 只有在 `try` 块没有抛出异常时才会执行。
>
> **try...except...finally**: `finally` 无论是否发生异常都会执行，通常用于资源清理。
>
> 
>
> **Q：什么是可迭代对象？可迭代对象的原理是什么？**
>
> 可迭代对象是指可以使用 `for` 循环遍历的对象，如 `list`, `tuple`, `str`, `dict` 等。其原理是对象实现了 `__iter__` 方法，返回一个迭代器对象。
>
> 
>
> **Q：with...as 的原理是什么？**
>
> `with...as` 语句用于简化资源管理，如文件操作。它的原理是 `with` 会调用对象的 `__enter__()` 方法，进入上下文管理器，并在 `with` 块执行完后调用 `__exit__()` 方法来清理资源。
>
> 
>
> **Q：python 是单继承还是多继承？**
>
> Python 支持多继承，即一个类可以继承多个父类。
>
> 
>
> **Q：python 继承的顺序是什么？**
>
> Python 使用方法解析顺序（MRO），它定义了继承方法的查找顺序。对于多继承，Python 使用 C3 线性化算法来决定查找的顺序。
>
> 
>
> **Q：什么是元类？**
>
> 元类是类的类。它定义了如何创建类对象，通常用于动态创建类或修改类的行为。
>
> 
>
> **Q：为什么都说 python 慢？**
>
> Python 的运行速度比一些编译型语言如 C 或 C++ 慢，主要因为它是解释型语言，且有全局解释器锁（GIL）限制了多线程的执行效率。另外，Python 是动态类型语言，类型检查和内存管理增加了额外开销。



#### Pytest

> **1. 什么是 pytest？它有哪些优点？**
>
> - **答案：** pytest 是一个成熟的全功能 Python 测试工具。它帮助你编写更好的程序，使测试变得简单且可扩展。
> - 优点：
>   - 简单易用：语法简洁，易于上手。
>   - 强大的断言：使用 Python 原生的 `assert` 语句，无需记忆额外的断言方法。
>   - 丰富的插件：拥有大量第三方插件，可以扩展其功能，如覆盖率测试、性能测试等。
>   - 灵活的参数化：支持参数化测试，可以轻松地对同一测试用例使用不同的输入进行测试。
>   - fixture 功能：fixture 提供了强大的测试装置管理功能，可以方便地管理测试环境的准备和清理。
>   - 能够很好的兼容unittest。
>
> **2. pytest 中的 fixture 是什么？如何使用？**
>
> - **答案：** fixture 是 pytest 提供的一种用于测试装置（test fixture）的机制，用于在测试用例执行前后进行一些准备和清理工作，例如数据库连接、测试数据准备等。
> - 使用方法：
>   - 使用 `@pytest.fixture` 装饰器定义 fixture 函数。
>   - 在测试用例函数中，将 fixture 函数名作为参数传入，pytest 会自动调用 fixture 函数并将其返回值传递给测试用例。
>   - Fixture 的作用域，通过scope参数来控制，包括session，module，class，function。
>
> **3. pytest 中的参数化测试是什么？如何实现？**
>
> - **答案：** 参数化测试允许使用不同的输入数据多次运行同一个测试用例，从而提高测试的覆盖率。
> - 实现方法：
>   - 使用 `@pytest.mark.parametrize` 装饰器，并提供参数名和参数值列表。
>   - 在测试用例函数中，使用参数名作为参数接收参数值。
>
> **4. pytest 中的断言如何使用？**
>
> - **答案：** pytest 使用 Python 原生的 `assert` 语句进行断言。
> - 使用方法：
>   - `assert expression`：判断表达式是否为真。
>   - `assert expression, message`：如果表达式为假，则显示指定的错误信息。
>
> **5. pytest 如何运行测试用例？**
>
> - 答案：
>   - 在命令行中，使用 `pytest` 命令运行当前目录及其子目录下的所有测试用例。
>   - 可以使用 `pytest 文件名` 运行指定文件中的测试用例。
>   - 可以使用 `pytest 目录名` 运行指定目录下的测试用例。
>   - 可以使用 `pytest 文件名::测试函数名` 运行指定测试用例。
>   - 可以使用 `-k` 选项通过表达式选择要运行的测试用例。
>   - 可以使用`-m`选项来运行标记的测试用例。
>
> **6. pytest 中的 hook 函数是什么？如何使用？**
>
> - **答案：** hook 函数是 pytest 预定义的函数，允许你在测试执行的不同阶段插入自定义逻辑，例如修改测试行为、收集测试结果等。
> - 使用方法：
>   - 在 `conftest.py` 文件中定义 hook 函数，函数名必须符合 pytest 规定的命名规范（例如 `pytest_collection_modifyitems`）。
>   - pytest 会自动调用这些 hook 函数。
>
> **7. conftest.py 文件的作用是什么？**
>
> - **答案：** `conftest.py` 是一个特殊的 pytest 配置文件，用于存放 fixture 函数、hook 函数和插件等，可以在整个测试项目中共享。
>
> **8. pytest 如何生成测试报告？**
>
> - 答案：
>   - 可以使用 `pytest --junitxml=path/to/report.xml` 生成 JUnit XML 格式的测试报告。
>   - 可以使用`pytest --html=path/to/report.html`生成html格式的测试报告。
>   - pytest-html 插件可以生成 HTML 格式的测试报告，更易于阅读。
>
> **9. pytest 的标记（mark）是什么？如何使用？**
>
> - **答案：** 标记（mark）用于给测试用例添加元数据，例如分类、分组等，方便对测试用例进行管理和筛选。
> - 使用方法：
>   - 使用 `@pytest.mark.标记名` 装饰器给测试用例添加标记。
>   - 可以使用`-m`选项来运行标记的测试用例。
>
> **10. pytest 如何处理异常？**
>
> - 答案：
>   - 可以使用 `pytest.raises` 上下文管理器断言测试用例是否抛出指定的异常。
>   - 可以使用`try...except`语句来捕获异常并进行处理。



#### Linux

> **Q：linux切换目录**
>
> cd 
>
> **Q：linux命令，统计一个文本中关键字出现的次数**
>
> `-o` 选项表示只输出匹配到的关键字，而不是整行。
>
> grep -o "关键字" 文件名 | wc -l
>
> **Q：linux 查找当前目录下所有后缀为 .py文件**
>
> find . -name "*.py"
>
> ls *.py
>
> **Q：知道的linux常用命令：查看指定端口进程**
>
> ```
> netstat -tunlp | grep 端口号
> ```
>
> 参数说明：
>
> - `-t`：显示 TCP 连接。
> - `-u`：显示 UDP 连接。
> - `-n`：以数字形式显示地址和端口号。
> - `-l`：显示监听状态的套接字。
> - `-p`：显示进程 ID 和进程名称。
> - `grep 端口号`：过滤出包含指定端口号的行
>
> **Q：cd - 和 cd ～**
>
> `cd ~`：始终切换到用户主目录。
>
> `cd -`：切换到上一个工作目录。
>
> **Q：linux 查看某个进程命令怎么写**
>
> ```
> ps aux | grep 进程名称
> ```
>
> - `aux`：显示所有用户的进程，包括没有控制终端的进程。
> - `|`：管道符号，将 `ps` 命令的输出传递给 `grep` 命令。
> - `grep 进程名称`：过滤出包含指定进程名称的行。
>
> ```
> ps -p PID
> ```
>
> - `-p PID`：显示指定 PID 的进程。
>
> **Q：如何查看日志？怎么查看后500条日志？**
>
> **`tail -n`：**
>
> - `tail -n` 命令可以指定显示的行数。
> - 示例：`tail -n 500 /var/log/syslog`
> - 这个命令可以显示syslog这个日志文件的最后500行。
>
> **结合 `less`：**
>
> - `tail -n 500 /var/log/syslog | less`
> - 这个命令可以将日志文件的最后500行，通过管道命令'|'传递给less命令，然后通过less命令进行分页显示，这样可以更方便的翻阅日志。
>
> 
>
> **Q：awk有什么用？如何用（举个例子）？**
>
> `awk` 是一种强大的文本处理工具，它允许你以灵活的方式提取、转换和格式化文本数据。
>
> ```
> awk '模式 {动作}' 文件名
> ```
>
> - **模式：** 用于匹配文本行的规则，例如正则表达式、条件表达式等。
> - **动作：** 在匹配到的文本行上执行的操作，例如打印、计算、赋值等。
>
> 
>
> 假设有一个名为 `data.txt` 的文本文件，内容如下：
>
> ```
> apple 10 2.5
> banana 5 1.8
> orange 8 3.2
> ```
>
> 1. 提取第一列和第三列：
>
> Bash
>
> ```shell
> awk '{print $1, $3}' data.txt
> ```
>
> **Q：如何查看系统性能？**
>
> **top/htop：** 实时显示系统进程和资源使用情况。`htop` 是 `top` 的增强版本，提供更友好的界面。
>
> **vmstat：** 显示虚拟内存、进程、CPU 活动和 I/O 等信息。
>
> **iostat：** 显示磁盘 I/O 统计信息。
>
> **free：** 显示内存使用情况。
>
> **df/du：** 显示磁盘空间使用情况。
>
> **netstat/ss：** 显示网络连接和统计信息。
>
> **Q：如何查看剩余磁盘空间大小？**
>
> 
>
> **Q：如何查看目录占空间大小？**
>
> **df/du：** 显示磁盘空间使用情况。
>
> du -sh .
>
> `du`：命令本身。
>
> `-s`：汇总显示，只显示总计。
>
> `-h`：以人类可读的格式显示（例如，KB、MB、GB）。
>
> `.`：表示当前目录。
>
> 
>
> **Q：测试服务器之间怎么进行文件拷贝？**
>
> 从本地服务器拷贝到远程服务器：
>
> Bash
>
> ```
> scp /path/to/local/file username@remote_server_ip:/path/to/remote/directory
> ```
>
> 从远程服务器拷贝到本地服务器：
>
> Bash
>
> ```
> scp username@remote_server_ip:/path/to/remote/file /path/to/local/directory
> ```
>
> 拷贝文件夹需要添加 -r 参数
>
> Bash
>
> ```
> scp -r /path/to/local/file username@remote_server_ip:/path/to/remote/directory
> ```
>
> 
>
> **Q：sed 有什么用？如何用（举个例子）？**
>
> `sed`（Stream Editor）是一种强大的文本处理工具，它允许你对文本进行搜索、替换、删除和插入等操作。`sed` 以行为单位处理文本，非常适合处理大型文件。
>
> ```
> sed '命令' 文件名
> ```
>
> - **命令：** 指定要执行的操作，例如 `s`（替换）、`d`（删除）、`a`（追加）、`i`（插入）、`p`（打印）等。
>
> **常用命令和选项：**
>
> - **`s/旧字符串/新字符串/g`：** 替换命令，`g` 表示全局替换。
> - **`d`：** 删除命令。
> - **`-i`：** 直接修改文件内容（默认情况下，`sed` 只输出修改后的内容，不修改原文件）。
> - **`-n`：** 静默模式，只输出匹配到的行。
>
> 
>
> **Q：怎么杀死一个进程？**
>
>  **使用 `kill` 命令（基本方法）：**
>
> - `kill` 命令用于向进程发送信号，其中最常用的信号是 `SIGTERM`（终止）和 `SIGKILL`（强制终止）。
>
>   - **终止进程（SIGTERM）：**
>
>     Bash
>
>     ```
>     kill PID
>     ```
>
>     或者
>
>     Bash
>
>     ```
>     kill -15 PID
>     ```
>
>     - `PID`：要终止的进程的 PID。
>     - 这是默认的终止信号，它允许进程在终止前进行清理工作。
>
>   - **强制终止进程（SIGKILL）：**
>
>     Bash
>
>     ```
>     kill -9 PID
>     ```
>
> 使用 `kill -9` 强制终止进程可能会导致数据丢失或系统不稳定。
>
> 在终止系统关键进程之前，请务必小心。
>
> 
>
> **Q：怎么递归删除一个目录下的所有文件？**
>
> ```
> rm -rf 目录路径
> ```
>
> - `rm`：删除文件或目录的命令。
> - `-r`：递归删除目录及其内容。
> - `-f`：强制删除，不提示确认。
> - `目录路径`：要删除的目录的路径。
>
> 
>
> **Q：怎么查看内存大小？**
>
> 
>
> **Q：怎么查看 CPU 使用情况？**
>
> top
>
> **Q：怎么重启 Linux 服务器？**
>
> **. 使用 `reboot` 命令：**
>
> - `reboot` 命令会立即重启服务器。
>
> - 这是最常用的重启命令，适用于大多数情况。
>
> - 命令格式：
>
>   Bash
>
>   ```
>   sudo reboot
>   ```
>
> - 需要 `sudo` 权限才能执行。
>
> **2. 使用 `shutdown` 命令：**
>
> - `shutdown` 命令提供了更灵活的重启选项。
>
> - 你可以指定重启时间，并向所有登录用户发送警告信息。
>
> - 命令格式：
>
>   Bash
>
>   ```
>   sudo shutdown -r now
>   ```
>
>   - `-r`：表示重启。
>   - `now`：表示立即重启。
>   - 你也可以指定一个时间，例如 `sudo shutdown -r +10` 表示 10 分钟后重启。
>
> 
>
> **Q：怎么打印出一个文件的第500-1000行？**
>
> sed -n '500,1000p' 文件名
>
> `-n`：静默模式，只输出匹配到的行。
>
> `'500,1000p'`：指定要打印的行范围，`p` 表示打印。



#### Docker

>**如何查看 Docker 容器的日志？**
>使用 docker logs 命令查看容器日志：
>
>docker logs <container_id>
>
>使用 -f 选项实时跟踪日志输出：
>
>docker logs -f <container_id>
>
>
>
>**如何配置 Docker 容器的日志驱动？**
>在启动容器时使用 --log-driver 选项配置日志驱动。例如，使用 syslog 日志驱动：
>
>docker run --log-driver=syslog --log-opt syslog-address=tcp://192.168.0.42:123 <image>
>
>
>
>**如何限制 Docker 容器日志的大小？**
>使用 --log-opt 选项配置日志轮转。例如，限制日志文件的最大大小为10MB，并保留最多3个日志文件：
>
>docker run --log-opt max-size=10m --log-opt max-file=3 <image>
>
>
>
>**Docker 支持哪些日志驱动？**
>Docker 支持多种日志驱动，包括：
>
>json-file（默认）
>syslog
>journald
>gelf
>fluentd
>awslogs
>splunk
>
>
>
>**如何将 Docker 容器的日志发送到远程日志服务器？**
>可以使用支持远程日志记录的日志驱动，如 syslog、gelf、fluentd 等。例如，使用 syslog 日志驱动将日志发送到远程服务器：
>
>docker run --log-driver=syslog --log-opt syslog-address=tcp://192.168.0.42:123 <image>
>
>
>
>**如何查看 Docker 守护进程的日志？**
>Docker 守护进程的日志通常记录在系统日志中，具体位置取决于操作系统：
>
>Linux（systemd）：使用 journalctl -u docker 查看 Docker 守护进程日志。
>Linux（非 systemd）：查看 /var/log/docker.log 文件。
>Windows：查看 Event Viewer 中的 Docker 事件。
>
>
>
>**如何处理 Docker 容器日志的持久化和分析？**
>可以使用日志收集和分析工具，如 ELK（Elasticsearch、Logstash、Kibana）栈、Fluentd、Splunk 等，将容器日志集中收集、存储和分析。配置合适的日志驱动（如 gelf、fluentd 等），并将日志发送到日志收集服务进行持久化和分析。
>
>
>
>**请列举Docker的常用基础命令 ？**
>docker logs：查看容器内标准输出。
>docker run：启动容器。
>docker stop：停止容器。
>docker ps：查看正在运行的容器。
>docker port：查看容器的端口映射。
>docker top：查看容器内部运行的进程。
>docker inspect：查看容器的底层信息。
>docker start：启动容器。
>docker ps -l：查看最后一次创建的容器。
>docker rm：移除容器（移除容器时，容器必须为停止状态）。
>docker name：为创建的容器命名。
>docker -d：在run后面加上-d参数，则会创建一个守护式容器在后台运行。
>docker -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射。
>docker -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个-v做多个目录或文件映射。
>docker build：构建镜像。
>docker tag：添加标签。
>
>
>
>**简述什么是 DockerFile？**
>Dockerfile是一个文本文件，其中包含了一系列用于构建Docker镜像的指令。这些指令定义了如何自动构建Docker镜像，以及如何在容器内部运行应用程序。Dockerfile使开发人员可以轻松地定义、共享和重复使用Docker镜像，以便在开发、测试和生产环境中快速部署应用程序。



#### 非关系型数据库

> **Q：非关系型数据库有哪些？**
>
> redis、mongodb、es
>
> **Q：Redis的数据结构有哪些？**
>
> **1. 字符串（String）：**
>
> - 字符串是 Redis 中最基本的数据结构，它可以存储文本、数字或二进制数据。
> - 字符串类型的值实际可以是字符串（简单和复杂字符串，例如JSON、XML）、数值（整数、浮点数），甚至是二进制（图片、音频、视频），不过值最大不能超过512MB。
> - 字符串常用操作：`SET`、`GET`、`DEL`、`INCR`、`DECR` 等。
>
> **2. 列表（List）：**
>
> - 列表是一个有序的字符串集合，可以在列表的两端进行插入和删除操作。
> - 列表常用操作：`LPUSH`、`RPUSH`、`LPOP`、`RPOP`、`LRANGE` 等。
> - 应用场景：消息队列、最新消息列表等。
>
> **3. 哈希（Hash）：**
>
> - 哈希是一个键值对集合，类似于字典，可以存储对象。
> - 哈希常用操作：`HSET`、`HGET`、`HDEL`、`HGETALL` 等。
> - 应用场景：存储用户信息、对象缓存等。
>
> **4. 集合（Set）：**
>
> - 集合是一个无序的字符串集合，不允许重复元素。
> - 集合常用操作：`SADD`、`SREM`、`SMEMBERS`、`SINTER`、`SUNION` 等。
> - 应用场景：标签系统、社交关系等。
>
> **5. 有序集合（Sorted Set）：**
>
> - 有序集合是一个有序的字符串集合，每个元素都关联一个分数（score），用于排序。
> - 有序集合常用操作：`ZADD`、`ZREM`、`ZRANGE`、`ZSCORE` 等。
> - 应用场景：排行榜、计数器等。
>
> 
>
> **Q：Redis 的用途？**
>
> Redis（Remote Dictionary Server）是一个开源的内存数据结构存储系统，它可以用作数据库、缓存和消息代理。由于其高性能和丰富的数据结构，Redis 在各种应用场景中都有广泛的应用。
>
> 
>
> **Q：Redis一秒能写入多少数据？**
>
> Redis 的写入性能受到多种因素的影响，因此很难给出一个确定的数值。以下是一些影响 Redis 写入性能的关键因素：
>
> 硬件配置、数据大小、网络环境、redis配置
>
> 
>
> **Q：Redis为什么快？**
>
> **1. 基于内存的数据存储：**
>
> - Redis 将所有数据存储在内存中，避免了磁盘 I/O 操作的延迟。
> - 内存读写速度远高于磁盘读写速度，这是 Redis 高性能的基础。
>
> **2. 单线程模型：**
>
> - Redis 的核心处理逻辑是单线程的，避免了多线程上下文切换和锁竞争的开销。
> - 单线程模型简化了代码实现，降低了并发控制的复杂度。
> - Redis 通过异步 I/O 和多路复用技术，在单线程下也能高效处理大量并发请求。
>
> **3. 高效的数据结构：**
>
> - Redis 提供了多种高效的数据结构，如跳跃表、哈希表等，优化了数据访问和操作的性能。
> - 这些数据结构经过精心设计，能够在内存中快速执行各种操作。
>
> **4. I/O 多路复用：**
>
> - Redis 使用 I/O 多路复用技术（如 epoll、select），在一个线程中同时处理多个客户端连接。
> - 这使得 Redis 能够在高并发场景下高效地处理大量请求。
>
> **5. 底层采用 C 语言实现：**
>
> - C 语言是一种高性能的编程语言，Redis 使用 C 语言实现，保证了其底层的高效性。
>
> 
>
> **Q：Redis的过期时间怎么设置？哪些场景适合缓存更长时间？**
>
> **使用 `EXPIRE` 命令（以秒为单位）：**
>
> - `EXPIRE key seconds`：设置 `key` 在 `seconds` 秒后过期。
> - 示例：`EXPIRE mykey 60`（设置 `mykey` 在 60 秒后过期）。
>
> **2. 使用 `PEXPIRE` 命令（以毫秒为单位）：**
>
> - `PEXPIRE key milliseconds`：设置 `key` 在 `milliseconds` 毫秒后过期。
> - 示例：`PEXPIRE mykey 60000`（设置 `mykey` 在 60000 毫秒后过期）。
>
> **3. 使用 `EXPIREAT` 命令（基于时间戳）：**
>
> - `EXPIREAT key timestamp`：设置 `key` 在 `timestamp` 时间戳（Unix 时间戳，以秒为单位）后过期。
> - 示例：`EXPIREAT mykey 1678886400`（设置 `mykey` 在 2023 年 3 月 16 日 00:00:00 UTC 过期）。
>
> **4. 在 `SET` 命令中使用过期选项：**
>
> - `SET key value EX seconds`：设置 `key` 的值为 `value`，并在 `seconds` 秒后过期。
> - `SET key value PX milliseconds`：设置 `key` 的值为 `value`，并在 `milliseconds` 毫秒后过期。
> - 示例：`SET mykey "hello" EX 60`（设置 `mykey` 的值为 "hello"，并在 60 秒后过期）。
>
> **哪些场景适合缓存更长时间？**
>
> - 静态内容：
>   - 例如，网站的静态 HTML 页面、图片、CSS、JavaScript 文件等。
>   - 这些内容很少变化，可以设置较长的过期时间，甚至永久缓存。
> - 不经常变化的数据：
>   - 例如，用户信息、产品信息、配置信息等。
>   - 这些数据更新频率较低，可以设置较长的过期时间。
> - 计算成本高的数据：
>   - 例如，复杂的查询结果、聚合数据、统计数据等。
>   - 这些数据计算成本较高，可以设置较长的过期时间，避免重复计算。
> - 访问频率低的数据：
>   - 例如，历史数据、归档数据等。
>   - 这些数据访问频率较低，可以设置较长的过期时间，减少内存占用。
>
> **设置过期时间需要考虑的因素：**
>
> - **数据更新频率：** 数据更新越频繁，过期时间应该设置得越短。
> - **数据重要性：** 重要数据应该设置较短的过期时间，确保数据的实时性。
> - **缓存大小：** 缓存空间有限，过期时间过长可能导致缓存溢出。
> - **业务需求：** 根据具体的业务需求，设置合适的过期时间。
>
> 
>
> **Q：什么是缓存雪崩？**
>
> 缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，请求直接落到数据库上，引起数据库压力过大甚至宕机。缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。
>
> **使用分布式锁：**
>
> - 在查询数据库时，使用分布式锁来避免并发查询导致的数据库压力增大。
>
> **Redis 集群：**
>
> - 使用 Redis 集群，提高 Redis 服务的可用性，避免单点故障。
>
> **Q：什么是缓存击穿？缓存击穿和缓存穿透的区别是什么？**
>
> 缓存击穿是指一个热点 Key（高并发访问的 Key）在缓存中过期失效，此时大量并发请求直接穿透缓存，全部到达数据库，导致数据库压力骤增，甚至崩溃。
>
> **缓存击穿的特点：**
>
> - **热点 Key：** 击穿通常发生在访问量极高的热点数据上。
> - **缓存失效：** 缓存中的热点数据因过期而失效。
> - **数据库压力：** 大量并发请求直接访问数据库，造成压力。
>
> **缓存击穿和缓存穿透的区别：**
>
> 虽然缓存击穿和缓存穿透都会导致数据库压力增大，但它们之间存在本质区别：
>
> - 缓存穿透：
>   - 指查询根本不存在于缓存和数据库中的数据。
>   - 大量请求不断查询不存在的 Key，导致每次请求都穿透缓存，直接访问数据库。
>   - 这种情况下，缓存形同虚设，数据库压力持续增大。
>   - 根本原因：查询不存在的数据
> - 缓存击穿：
>   - 指查询存在于数据库中，但缓存中已过期失效的热点数据。
>   - 大量并发请求同时查询这个过期失效的 Key，导致请求穿透缓存，直接访问数据库。
>   - 这种情况下，数据库压力在缓存失效的瞬间激增。
>   - 根本原因：热点Key缓存失效
>
> **如何解决缓存击穿：**
>
> - 设置热点 Key 永不过期：
>   - 对于访问量极高的热点数据，可以考虑设置永不过期，或者延长其过期时间。
> - **使用二级缓存：**
>   - 设置一个永不过期的“备份”缓存，当主缓存失效时，先从备份缓存读取数据，然后异步更新主缓存。
>
> 
>
> **Q：Redis 适合做消息队列吗？为什么？**
>
> 可以做消息队列，在需要比较高的性能的情况可以用redis来做消息队列
>
> **Q：Redis 的数据是存储在内存当中的，假如断电之后就会造成数据丢失，那怎么对 Redis 进行数据固化？**
>
> Redis 提供了两种主要的数据持久化机制，可以将内存中的数据固化到磁盘上：RDB，



#### 数据库基本理论

> **Q：有哪些数据库优化的方式？**
>
> 读写分离、批量操作、升级硬件
>
> **索引优化：**
>
> - 创建合适的索引：
>   - 在经常用于查询条件的列上创建索引。
>   - 注意避免创建过多索引，因为索引会增加写操作的开销。
> - 优化索引：
>   - 定期分析索引使用情况，删除不必要的索引。
>   - 考虑使用复合索引，优化多列查询。
> - 避免索引失效：
>   - 避免在 where 子句中对字段进行函数操作，这会导致索引失效。
>
> **SQL 查询优化：**
>
> - 避免使用 SELECT *：
>   - 只查询需要的列，减少数据传输量。
> - 优化 WHERE 子句：
>   - 尽量使用索引列作为查询条件。
>   - 避免在 WHERE 子句中使用 OR，可以使用 UNION 或 IN 替代。
> - 优化 JOIN 查询：
>   - 尽量使用 INNER JOIN，避免使用全外连接。
>   - 确保 JOIN 的列上有索引。
> - 使用 EXPLAIN 分析查询：
>   - 通过 EXPLAIN 分析查询执行计划，找出性能瓶颈。
>
> **缓存优化：**
>
> - 使用数据库缓存：
>   - 利用数据库自身的查询缓存。
> - 使用外部缓存：
>   - 使用 Redis、Memcached 等外部缓存，减轻数据库压力。
>
> 
>
> **Q：关系型数据库和非关系型数据库的区别？**
>
> ![image-20250303122945176](.\assets\image-20250303122945176.png)
>
> **Q：数据库的事务有什么用？什么时候应该使用事务，什么时候不该使用事务？**
>
> 数据库事务是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。事务的目的是为了保证数据库操作的原子性、一致性、隔离性和持久性（ACID），确保数据在并发访问和系统故障时保持正确状态。
>
> **事务的四大特性（ACID）：**
>
> - **原子性（Atomicity）：** 事务是一个不可分割的操作序列，要么全部执行成功，要么全部不执行。
> - **一致性（Consistency）：** 事务执行前后，数据库必须保持一致性状态。
> - **隔离性（Isolation）：** 并发执行的事务之间相互隔离，一个事务的执行不应影响其他事务。
> - **持久性（Durability）：** 已提交的事务的修改是永久性的，即使系统发生故障也不会丢失。
>
> **事务的用途：**
>
> - **保证数据完整性：** 在复杂操作中，确保数据的一致性和正确性。
> - **并发控制：** 在多用户并发访问数据库时，防止数据冲突和错误。
> - **错误恢复：** 在事务执行过程中发生错误时，回滚事务，保证数据回到初始状态。
>
> **何时应该使用事务：**
>
> - **涉及多个相关操作：** 当一个业务操作涉及多个数据库操作时，应该使用事务保证这些操作的原子性。例如，银行转账，需要同时更新两个账户的余额。
> - **需要保证数据一致性：** 当业务操作需要保证数据在任何情况下都保持一致性时，应该使用事务。例如，订单处理，需要同时更新订单表、商品表和库存表。
> - **并发访问频繁：** 当多个用户同时访问和修改同一份数据时，应该使用事务保证数据的隔离性和一致性。例如，在线购物网站的库存管理。
>
> **何时不该使用事务：**
>
> - **简单的查询操作：** 如果只是简单的查询数据库，不需要修改数据，则不需要使用事务。
> - **只读操作：** 如果只是读取数据库中的数据，不需要修改数据，则不需要使用事务。
> - **对性能要求极高：** 事务会带来一定的性能开销。在对性能要求极高的场景下，可以考虑牺牲部分数据一致性，不使用事务。
> - **数据量非常大的批量操作：** 对于数据量非常大的批量操作，如果使用事务，可能会导致事务执行时间过长，影响数据库性能。可以考虑将批量操作拆分成多个小事务，或者使用其他优化手段。
>
> 
>
> **Q：数据库索引有什么用？什么是联合索引？**
>
> 数据库索引是一种数据结构，用于提高数据库查询的速度。它类似于书籍的目录，可以帮助数据库快速定位到包含特定数据的行，而无需扫描整个表。
>
> **数据库索引的作用：**
>
> - 加速查询：
>   - 索引可以显著减少数据库需要扫描的数据量，从而提高查询速度。
>   - 对于包含大量数据的表，索引的优势尤为明显。
> - 保证数据唯一性：
>   - 唯一索引可以确保表中的某一列或多列的值是唯一的。
>   - 这有助于维护数据的完整性。
> - 加速排序和分组：
>   - 索引可以按照特定的顺序存储数据，从而加速排序和分组操作。
>
> **什么是联合索引？**
>
> 联合索引（也称为复合索引或组合索引）是指由多个列组合而成的索引。与单列索引只针对单个列进行索引不同，联合索引可以同时对多个列进行索引，以提高多列查询的性能。
>
> **联合索引的特点：**
>
> - 多列组合：
>   - 联合索引包含多个列，这些列按照特定的顺序组合在一起。
> - 最左前缀原则：
>   - 联合索引遵循最左前缀原则，这意味着查询条件必须包含联合索引的最左边的列，才能使用该索引。
>   - 例如，如果有一个联合索引 (A, B, C)，那么查询条件包含 A、(A, B) 或 (A, B, C) 时，可以使用该索引。
>   - 但是，查询条件只包含 B 或 C 时，无法使用该索引。
> - 提高多列查询性能：
>   - 联合索引可以显著提高多列查询的性能，特别是当查询条件包含联合索引的所有列或最左边的列时。
>
> **联合索引的优势：**
>
> - 减少 I/O 操作：
>   - 联合索引可以将多个列的数据存储在一起，减少数据库需要读取的数据块数量，从而减少 I/O 操作。
> - 覆盖索引：
>   - 如果查询只需要访问联合索引中包含的列，那么数据库可以直接从索引中获取数据，而无需访问数据表，从而提高查询速度。
> - 提高排序和分组性能：
>   - 联合索引可以按照特定的顺序存储数据，从而加速排序和分组操作。
>
> **联合索引的注意事项：**
>
> - 索引列的顺序：
>   - 联合索引的性能与索引列的顺序密切相关。
>   - 应该将最常用的查询条件放在联合索引的最左边。
> - 索引列的数量：
>   - 联合索引包含的列越多，索引的大小就越大，从而增加存储空间和维护成本。
>   - 应该根据实际需求选择合适的索引列数量。
> - 索引维护成本：
>   - 索引会增加写操作的开销，因为每次插入、更新或删除数据时，都需要更新索引。
>   - 应该避免创建过多索引。
>
> 
>
> **Q：主键适合用自定义ID还是自动ID？**
>
> **小型应用或单体应用：**
>
> - 如果应用规模较小，对性能要求较高，且不需要全局唯一性，建议使用自动 ID。
>
> **分布式应用或微服务：**
>
> - 如果应用需要全局唯一性，或者需要在多个数据库之间进行数据整合，建议使用自定义 ID。
>
> **安全性要求高的应用：**
>
> - 如果对安全性要求较高，建议使用自定义 ID。
>
> **数据迁移频繁的应用：**
>
> - 如果数据迁移或表合并频繁，建议使用自定义 ID。
>
> 
>
> **Q：外键是什么？为什么大公司有时候不建议使用外键？**
>
> 外键（Foreign Key）是关系型数据库中用于建立和加强两个表数据之间链接的一种机制。外键约束确保了数据的一致性和完整性。然而，在大规模、高并发的系统中，外键的使用可能会带来一些性能和维护上的挑战，这也是为什么一些大公司在特定情况下不建议使用外键的原因。
>
> 
>
> **Q：索引设置得越多越好吗？索引得优缺点是什么？**
>
> 并不是
>
> **选择合适的列：**
>
> - 在经常用于查询条件的列上创建索引。
> - 在经常用于排序和分组的列上创建索引。
>
> 优点：加速查询、缺点：增加存储空间占用、可能会索引失效
>
> 
>
> **Q：为什么会造成数据库死锁？怎么解决？**
>
> 数据库死锁是指两个或多个事务在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法继续推进下去。
>
> **造成数据库死锁的原因：**
>
> 1. 资源竞争：
>    - 多个事务试图同时访问相同的资源（如数据库表、行、页或锁），但它们请求资源的顺序不同，导致相互等待。
> 2. 未释放资源：
>    - 事务在使用完资源后未及时释放，导致其他事务无法获得所需的资源。
>    - 这可能是由于程序错误或异常情况引起的。
> 3. 事务隔离级别：
>    - 较高的事务隔离级别（如可串行化）会增加死锁的风险，因为它们会使用更严格的锁定策略。
> 4. 锁定顺序：
>    - 如果多个事务以不同的顺序锁定资源，可能会导致死锁。
>    - 例如，事务 A 先锁定资源 1，再请求资源 2；而事务 B 先锁定资源 2，再请求资源 1。
>
> **解决数据库死锁的方法：**
>
> 1. 避免死锁的发生：
>    - 优化事务设计：
>      - 尽量减少事务的持有锁的时间，减少事务的范围。
>      - 尽量避免在同一事务中访问多个资源。
>      - 使用较低的事务隔离级别。
>    - 统一资源访问顺序：
>      - 确保所有事务都以相同的顺序访问资源，避免循环等待。
>    - 使用索引：
>      - 合理的索引可以减少锁定范围，降低死锁的概率。
>    - 设置锁超时：
>      - 为锁设置超时时间，当事务等待锁的时间超过阈值时，自动释放锁。
> 2. 检测和解决死锁：
>    - 死锁检测：
>      - 数据库系统通常会自动检测死锁，并选择一个事务进行回滚，释放其持有的锁。
>    - 应用程序处理：
>      - 在应用程序中捕获死锁异常，并进行重试或回滚。
>      - 记录死锁日志，用于分析和优化。
> 3. 数据库配置优化：
>    - 调整死锁检测间隔：
>      - 根据实际情况调整死锁检测的频率。
>    - 调整锁等待超时时间：
>      - 设置合理的锁等待超时时间，避免长时间的等待。
>
> 
>
> **Q：事务都有哪些特点？**
>
> **原子性（Atomicity）**
>
> - 原子性意味着事务是一个不可分割的最小工作单元，事务中的所有操作要么全部成功执行，要么全部不执行。
> - 如果事务中的任何一个操作失败，整个事务都会回滚到事务开始之前的状态，就像事务从未发生过一样。
> - 这确保了事务的完整性，防止数据处于不一致的中间状态。
>
> **2. 一致性（Consistency）**
>
> - 一致性确保事务在执行前后，数据库从一个一致性状态转变到另一个一致性状态。
> - 事务必须遵守预定义的规则和约束，如主键约束、外键约束、唯一性约束等。
> - 一致性不仅指数据库的物理完整性，还包括业务逻辑上的完整性。
>
> **3. 隔离性（Isolation）**
>
> - 隔离性是指并发执行的事务之间应该相互隔离，一个事务的执行不应该影响其他事务的执行。
> - 不同的事务隔离级别定义了事务之间可见性的程度，常见的隔离级别包括读未提交、读已提交、可重复读和串行化。
> - 隔离性保证了并发环境下数据的正确性和一致性。
>
> **4. 持久性（Durability）**
>
> - 持久性意味着一旦事务提交，其所做的修改就会永久保存在数据库中，即使系统发生故障也不会丢失。
> - 通常通过事务日志（如 redo log）来实现持久性，确保事务提交后数据能够恢复。
> - 持久性保证了数据的可靠性和安全性。
>
> 
>
> **Q：数据库设计的三大范式是什么？**
>
> 第一范式（1NF）：强调的是列的原子性，即列不能够再拆分。
>
> 第二范式（2NF）：强调的是表中的列必须完全依赖于主键。
>
> 第三范式（3NF）：强调的是表中的列之间不能存在传递依赖。
>
> 
>
> **Q：为什么要进行分表分库？**
>
> 分库分表是一种数据库优化策略，它通过将大型数据库或表分割成更小、更易于管理的部分，从而提高数据库的性能、可扩展性和可用性。以下是进行分库分表的主要原因：
>
> **1. 解决性能瓶颈：**
>
> - 数据量过大：
>   - 当单表数据量达到千万甚至亿级别时，查询、插入、更新等操作的性能会明显下降。
>   - 分表可以将数据分散到多个表中，减少单个表的负担，提高查询速度。
> - 并发量过高：
>   - 高并发访问时，单个数据库可能无法承受巨大的压力，导致响应缓慢甚至崩溃。
>   - 分库可以将请求分散到多个数据库上，提高系统的并发处理能力。



#### SQL

> **Q：【手撕】数据库，查找一个学生两门功课都大于80分的姓名**
>
> - Students 表：
>   - `StudentID` (INT, 主键)
>   - `Name` (VARCHAR)
> - Scores 表：
>   - `StudentID` (INT, 外键，关联 Students.StudentID)
>   - `Course` (VARCHAR, 课程名称)
>   - `Score` (INT, 分数)
>
> ```sql
> SELECT s.Name
> FROM Students s
> JOIN Scores sc1 ON s.StudentID = sc1.StudentID
> JOIN Scores sc2 ON s.StudentID = sc2.StudentID
> WHERE sc1.Course = '课程1' AND sc1.Score > 80
>   AND sc2.Course = '课程2' AND sc2.Score > 80;
> ```
>
> 
>
> **Q：【手撕】联表查询2个表中工号为“123”的人的所有信息**
>
> - Employees 表：
>
>   - `EmployeeID` (INT, 主键, 工号)
>
>   - `Name` (VARCHAR, 姓名)
>
>   - `DepartmentID` (INT, 外键, 部门ID)
>
>   - `Position` (VARCHAR, 职位)
>
>   - `Salary` (DECIMAL, 工资)
>
> - Departments 表：
>   - `DepartmentID` (INT, 主键, 部门ID)
>   - `DepartmentName` (VARCHAR, 部门名称)
>   - `Location` (VARCHAR, 部门位置)
>
> ```sql
> SELECT *
> FROM Employees e
> JOIN Departments d ON e.DepartmentID = d.DepartmentID
> WHERE e.EmployeeID = '123';
> ```
>
> 
>
> **Q：【手撕】一个人员表，一个部门表，人员表中存了部门id，查人员表各部门表所有数据**
>
> - 人员表 (Employees):
>   - `EmployeeID` (INT, 主键, 人员ID)
>   - `Name` (VARCHAR, 姓名)
>   - `DepartmentID` (INT, 外键, 部门ID)
>   - `Position` (VARCHAR, 职位)
> - 部门表 (Departments):
>   - `DepartmentID` (INT, 主键, 部门ID)
>   - `DepartmentName` (VARCHAR, 部门名称)
>   - `Location` (VARCHAR, 部门位置)
>
> **1. 使用 INNER JOIN（内连接）：**
>
> - `INNER JOIN` 只返回两个表中匹配的行，即只有在人员表和部门表都有对应 `DepartmentID` 的记录才会显示。
>
> ```sql
> SELECT *
> FROM Employees e
> INNER JOIN Departments d ON e.DepartmentID = d.DepartmentID;
> ```
>
> 
>
> **Q：【手撕】查询一个城市列表里面重复的城市名，并且统计重复次数**
>
> 使用 `GROUP BY` 和 `COUNT`
>
> ```
> SELECT CityName, COUNT(*) AS RepeatCount
> FROM Cities
> GROUP BY CityName
> HAVING COUNT(*) > 1;
> ```
>
> 解释：
>
> - `GROUP BY CityName`: 将结果按照 `CityName` 列进行分组。
> - `COUNT(*)`: 统计每个分组中的行数，即重复次数。
> - `HAVING COUNT(*) > 1`: 筛选出重复次数大于 1 的城市名。
>
> 
>
> **Q：【手撕】查找一个学生成绩表中平均分数大于90分的学生名单**
>
> - Students 表：
>   - `StudentID` (INT, 主键)
>   - `Name` (VARCHAR, 姓名)
> - Scores 表：
>   - `StudentID` (INT, 外键，关联 Students.StudentID)
>   - `Course` (VARCHAR, 课程名称)
>   - `Score` (INT, 分数)
>
> ```sql
> SELECT s.Name
> FROM Students s
> JOIN Scores sc ON s.StudentID = sc.StudentID
> GROUP BY s.StudentID
> HAVING AVG(sc.Score) > 90;
> ```
>
> 
>
> **Q：【手撕】查找学生成绩表中平均成绩最高的同学**
>
> 要查找学生成绩表中平均成绩最高的同学，你需要使用 SQL 查询语句，具体取决于你的数据库结构。假设你有两个表：`Students`（学生表）和 `Scores`（成绩表）。
>
> **假设表结构如下：**
>
> - Students 表：
>   - `StudentID` (INT, 主键)
>   - `Name` (VARCHAR, 姓名)
> - Scores 表：
>   - `StudentID` (INT, 外键，关联 Students.StudentID)
>   - `Course` (VARCHAR, 课程名称)
>   - `Score` (INT, 分数)
>
> ```sql
> SELECT s.Name
> FROM Students s
> JOIN Scores sc ON s.StudentID = sc.StudentID
> GROUP BY s.StudentID
> ORDER BY AVG(sc.Score) DESC
> LIMIT 1;
> ```
>
> 
>
> **Q：删除数据的方式有哪些？说说 drop table和truncate table的区别？**
>
> 1.delete from table, drop table, truncate table
>
> ![image-20250303124558013](.\assets\image-20250303124558013.png)



#### 测试文档

> Q：**测试用例都包含哪些要素？**
>
> 用例ID/编号：唯一标识符
>
> 用例名称：简洁描述测试目的
>
> 测试目标/描述：详细说明测试内容
>
> 前置条件：执行测试前必须满足的条件
>
> 测试数据：测试中使用的输入数据
>
> 测试步骤：详细的操作步骤
>
> 预期结果：测试后应该达到的状态
>
> 实际结果：测试执行后的实际状态
>
> 测试结果：通过/失败
>
> 优先级/严重程度：测试用例的重要性
>
> 备注：其他相关信息
>
> 创建/修改人和日期
>
> 
>
> Q：**测试报告需要展示哪些要素？**
>
> 摘要：概述测试范围、时间和总体结果
>
> 测试环境：硬件、软件配置和版本信息
>
> 测试范围：说明测试的功能和未测试部分
>
> 测试执行情况：计划vs实际的测试进度
>
> 测试结果统计：通过/失败/阻塞/未执行等数量
>
> 缺陷分布：按严重性、模块等分类的缺陷统计
>
> 主要问题：关键缺陷的详细说明
>
> 质量评估：产品质量判断和风险评估
>
> 建议：改进建议和未来测试计划
>
> 附录：支持文档和详细测试数据
>
> 
>
> Q：**测试排期应该怎么估算？**
>
> 分解任务：将测试工作拆分为小任务
>
> 评估复杂度：根据功能复杂度确定测试难度
>
> 考虑历史数据：参考类似项目的实际耗时
>
> 加入缓冲时间：预留20-30%应对风险和变更
>
> 考虑资源因素：测试人员数量和技能水平
>
> 考虑依赖关系：环境准备、开发交付等前置条件
>
> 评估测试类型：功能测试、自动化测试等不同类型
>
> 专家评审：邀请有经验的测试人员评审估算
>
> 迭代调整：根据实际进度定期调整计划
>
> 
>
> Q：**测试程序设计的不合理 与 测试程序完善但是测试人员出现失误，哪一项更严重？**
>
> 测试程序设计不合理更严重。
>
> 测试程序不合理是系统性问题，会长期影响测试质量和效率
>
> 设计不合理可能导致大范围的测试盲点，无法发现关键缺陷
>
> 人员失误通常是偶发性的，可以通过复查或其他测试人员交叉验证来弥补
>
> Q：**有一个触发概率极低但是非常致命的BUG，明天项目一定要上线，你怎么处理，不用非得解决，就是问我怎么处理这种事。**
>
> 风险评估：精确评估bug触发概率和可能造成的损失
>
> 监控方案：设置专门监控机制，实时检测bug触发条件
>
> 降级方案：准备出现问题时的应急响应和功能降级策略
>
> 损害控制：评估最坏情况并准备损害控制措施
>
> 预警系统：实现自动预警，一旦出现征兆立即报警
>
> 修复计划：安排紧急修复团队随时待命
>
> 透明沟通：向产品、管理层和客户坦诚风险，取得共识



#### [PMP项目管理](https://metaso.cn/search/8598935371709796352/interactive?dataId=8598935371823042560&targetType=undefined)



#### Shell

> Q：什么场景下，适合编写 Shell 脚本来处理？
>
> 自动化系统管理任务
>
> - 批量文件操作（重命名、移动、备份）
> - 系统监控和日志处理
> - 定期清理临时文件或旧数据
> - 自动化系统备份
>
> 开发和构建流程
>
> - 代码编译和构建自动化
> - 开发环境配置
> - 持续集成/持续部署(CI/CD)流程
> - 依赖项安装和环境准备
>
> 数据处理
>
> - 日志文件分析和统计
> - 简单的文本处理和转换
> - CSV、JSON等结构化数据的基本处理
> - 数据提取和格式转换
>
> 网络和服务管理
>
> - 服务健康检查和重启
> - 网络连接测试和诊断
> - 简单的API调用和响应处理
> - 防火墙规则管理



#### TCP/IP

>Q：tcp三次握手
>
>1. **第一次握手（SYN）**：客户端发送一个带有SYN标志的报文段，包含初始序列号（Seq=x），表示请求建立连接。
>2. **第二次握手（SYN+ACK）**：服务器收到SYN后，回应一个SYN+ACK报文段，包含确认号（Ack=x+1）和自己的初始序列号（Seq=y），表示同意建立连接。
>3. **第三次握手（ACK）**：客户端收到SYN+ACK后，发送一个ACK报文段，确认号为Ack=y+1，序列号为Seq=x+1，表示连接建立完成。
>
>完成后，双方进入ESTABLISHED状态，可以开始数据传输。
>
>Q：访问一个网页（比如baidu.com）过程中用到哪些协议？
>
>**DNS解析**：客户端通过DNS协议（UDP或TCP）查询baidu.com的IP地址。
>
>**TCP连接**：通过三次握手与服务器建立TCP连接。
>
>**HTTPS请求**：客户端发送HTTPS请求（基于TCP和TLS/SSL），服务器返回网页数据。
>
>**数据传输**：网页内容（HTML、CSS、JS等）通过TCP传输，客户端渲染页面。
>
>**连接关闭**：数据传输完成后，TCP通过四次挥手关闭连接。 
